(* ::Package:: *)

(* ::Section:: *)
(*BeginPackage, usage statements*)


BeginPackage["SyntheticGeometryProving`"];


ProveGeometricFacts::usage="ProveGeometricFacts[scene] constructs a GeometricProofObject representing all the provable consequences of scene";
GeometricProofObject::usage="GeometricProofObject[...] represents a synthetic geometric proof generated by ProveGeometricFacts";


$geomPrintDebug = False;
Attributes[geomPrint] = {HoldAll};
geomPrint[a__] := If[$geomPrintDebug, Print @@ Riffle[Table[" --- ", {Length[{a}]}], {a}]];


(* ::Section:: *)
(*Applying theorems (main loops)*)


(* ::Subsection:: *)
(*preprocessing*)


(*

angles are assumed to be <180 AND a consistent (right-hand, let's say) orientation

enforce parallel lines are consistent with each other, and lengths EuclideanDistance are consistent with that.

Rectangle[a_,b_,c_,d_] 
\[RuleDelayed] {Parallel[{a,b},{d,c}], Parallel[{b,c},{a, d}], Angle[a,b,c]==90, Angle[b,c,d]==90,...,EuclideanDistance[a,b,len1],EuclideanDistance[d,c,len1],...}


An "area of rectangle = 66" given should become 4 lengths: EuclideanDistance[a,b,l],EuclideanDistance[c,d,l],EuclideanDistance[a,d,66/l],EuclideanDistance[b,c,66/l]

Potential pitfalls:
A trapezoid is a pair of parallels and a pair of points from each.
These points must be in their given order! (since parallel lines are given with points in same direction)
This way we can guarantee we are not talking about two triangles instead! (crossing between the parallels)


Another possible way to speedup, and simplify: in preprocessing, assign every entity a short "name", and use a dictionary. 
This will also eliminate (at least seperate) the need to handle the repeated-entity case
*)


(* 'dead-beginning theorems': translate more complex notions that SW includes in the nb into our standard ones, for speed/simplicity(?): 
so far, in order:
"orthocenter of ..."
"xxx and xxx are simliar triangles" (assume in that order of points)

maybe keep the original (not replsce), and ALSO in fixedthms ADD a sinlge Similar statement, and others follo

TODO: LineThrough (used to be GeometricLineSegment) seems useless, unless it contains a measurement, in which case make it GLength

SEE COORDINATEFREEREGIONS .WL FILE FOR LATEST? also: comment on this file
*)


prepRules = {

	(*(Triangle|Polygon)[{a_,b_,c_}]\[RuleDelayed]{Angle[a,b,c]\[Equal]Symbol["anga"],
									Angle[b,c,a]\[Equal]Symbol["angb"],
									Angle[c,a,b]\[Equal]Symbol["angc"]}, -- ONLY IF THESE ANGLES AREN'T ALREADY NAMED/GIVEN!! *)
	(*Polygon[]\[RuleDelayed]Table,*)
	(*here, oc[[1]] might be a user-given name, or autogenerated if not *)
	(oc_GeometricPoint == c:RegionCenter[Triangle[{x_,y_,z_}], type:"Incenter"]) 
	:> With[{(* if unnamed: newc = GeometricPoint["InCenter("<>x[[1]]<>y[[1]]<>z[[1]]<>")"]*)},
		{
		oc==RegionCenter[Triangle[{x,y,z}], "Incenter"](*why not just keep this*),
		2 Angle[x,y,oc] == Angle[x,y,z],
		2 Angle[y,z,oc] == Angle[y,z,x],
		2 Angle[z,x,oc] == Angle[z,x,y] (*, other thms? *)
		}
	],
	
	(*three times (n choose 2) new thms(!) for n number of triangles (3,9,...) *)
	Similar[ts:Triangle[{__}]..] 
	:> Flatten[
		{
			Angle@@(#[[1]]) == (*Symbol["sasasa"],*) Angle@@(#[[2]]) (*== Symbol["sasasa"]*), 
			Angle@@RotateLeft[#[[1]]] == (*Symbol["wwwwwq"],*) Angle@@RotateLeft[#[[2]]] (*== Symbol["wwwwwq"]*),
			Angle@@RotateRight[#[[1]]] == (*Symbol["iippjp"],*) Angle@@RotateRight[#[[2]]](* == Symbol["iippjp"]*)
		}&/@Subsets[{ts}[[All,1]],{2}]
		
	]
};


$AllowedGeometryHeads = (RegionCenter(*?*)|Equal|GeometricPoint|GeometricArea|CircleArcLength|CircleThrough|Circle|InfiniteLineThrough|LineThrough|Angle|EuclideanDistance|Triangle|Polygon|Similar|Parallel|Tangent|ConstructedInfiniteLineThrough|ConstructedGeometricPoint|ConstructedGeometricPointinProof|ConstructedEuclideanDistance);


(**)
PrepDiag[diag_]:=With[{augdiag = addpoints[addlines[fixCircles[Select[diag(*/.LineThrough->InfiniteLineThrough*), MatchQ[Head[#], $AllowedGeometryHeads]&]]]]},
			DeleteDuplicates[
				Replace[Flatten[Replace[augdiag,prepRules,1],1,List],
					{
						EuclideanDistance[z_,y_]==l_ 
						:> With[{zyline = Cases[augdiag,(InfiniteLineThrough|ConstructedInfiniteLineThrough)[{___,z|y,___,y|z,___}],3]},
							geomPrint[zyline,{y,z}];
							Switch[zyline,
								(*{(InfiniteLineThrough|ConstructedInfiniteLineThrough)[{___,y,___,z,___}],___}, EuclideanDistance[y,z]==Rationalize[l],
								{(InfiniteLineThrough|ConstructedInfiniteLineThrough)[{___,z,___,y,___}],___}, EuclideanDistance[z,y]==Rationalize[l],
								*)_, EuclideanDistance[Sequence@@Sort[{z,y}]]==Rationalize[l]
							]
						],
						GeometricArea[{x__}]==a_ :> GeometricArea[areaVertexSort[{x}]]==Rationalize[a]
					},1]
				]
			];


(*the canonical binary ordering of vertices (in which to display lengths, mostly)
should probably be according to how the lines/lengths were given in the input, eventually
COULD MEMOIZE THIS FUNCTION SO WE DONT NEED TO KEEP LOOKING AT THE G.LINES *)
vSort = Sort;

(*ternary(+ greater) canonical ordering of vertices (for areas/triangles,...) *)
areaVertexSort[{x__}] := With[{p = Ordering[{x},1](*Position[First@MaximalBy[{x},Identity]]*)},
	RotateLeft[{x},p]
]


(*only add lines if not already in a parallel*)
addlines[odiag_] := 
	With[{diag = Replace[odiag, a:(InfiniteLineThrough|LineThrough)[{__}]:>Parallel[a],1],
		  allpts=DeleteDuplicates@Flatten[Quiet@Cases[odiag,InfiniteLineThrough[{c_,a___}]|CircleThrough[{a___},c_,_]|EuclideanDistance[a_,c_]==_|(Angle[a_,b_,c_,___]==_):>{a,b,c},2]]},
		geomPrint["all pts",allpts];
		Join[Flatten[If[FreeQ[diag, InfiniteLineThrough[{___,#[[1]],___,#[[2]],___}]|InfiniteLineThrough[{___,#[[2]],___,#[[1]],___}]],Parallel[(*Constructed*)InfiniteLineThrough[#]],{}]&/@Subsets[allpts,{2}]],
			diag
		]
	]


(*todo: only add pts if not already at a dead end? *)
addpoints[diag_] := 
	Module[{i=1},
		Replace[diag,InfiniteLineThrough[{a__}]:>InfiniteLineThrough[{ConstructedGeometricPoint[i++],a,ConstructedGeometricPoint[i++]}],{2}]
	];


fixCircles[diag_] := 
	Module[{i=1},
		Replace[diag,CircleThrough[a_,c_] :> CircleThrough[a,c, ConstructedEuclideanDistance[i++]],{1}]
	]


simpFakeInts[a_?NumericQ] := If[Mod[a, 1] == 0, Round[a], a];
simpFakeInts[a___]:=a;


(* ::Subsection:: *)
(*main loops*)


(*$MaxPrecision=4; --using SetPrecision instead*)

(*final iterations can take up to a second using the current, totally naive, pattern-matching method.*)
$MaxIterations = 6;

(*for testing, or with ML randomness maybe we can't know when finished at all?*)
$AlwaysRunMaxIters = False;

(*$scoredata={};*)(*= code appends to this Global val for ML training*)

(*keeps track of last thms used - don't want to use then again right away*)
$lastThmGroupApplied = 0;

$TotalTimeLimit=35;


(*

-doesn't yet arrange proof, since doesnt keep track of dependency or thms used.
-blindly just grabs every fact

future: add ability to prove 'xert is a parallelogram' by collecting a set of facts and adding a last step

*)
(*GetProofFromDiag[diag_, thms_, HoldPattern[goal_], opts:OptionsPattern[]]:= 
*)


GetAllProofsFromDiag[GeometricScene[diag_List]|diag_List, thms_, opts:OptionsPattern[]] := 
Module[{i=0, olddiag=PrepDiag@diag, newdiag=None, justFacts=None, nicethms={}, justNiceFacts=None, justFacts2=None, knownvars={},
		starttime = AbsoluteTime[], timelimit = OptionValue[GetAllProofsFromDiag,{opts},"TimeLimit"],
		stepslimit = OptionValue[GetAllProofsFromDiag,{opts},"StepsLimit"],
		(*scheduling functions for running the Reduce solver, and for using "nice thms"*)
		reducesched = (Mod[#,3]==2 || #==1 (*&& False*))&, checkCompletesched, nicethmsched = ((Mod[#,5]!=4)||True)&, pfFlag = !FreeQ[DownValues[applyTheorem],applyAndAddProof|applyAndPrintAndAddProof]
		},
	checkCompletesched = (!nicethmsched[#] && reducesched[#])&;
	geomPrint["olddiag0", pfFlag];
	If[pfFlag,
		geomPrint["olddiag1: pfFlag ON...",Length[olddiag]];
		olddiag = initProofs[olddiag];
		geomPrint["olddiag2",Length[olddiag](*,olddiag*)];
		
		
		nicethms = thms(* it's way faster to DeleteCases of less import from diag!! (but what if they are needed intermediate step?)*)
		(*Replace[thms,
						HoldPattern[a_ :> applyTheorem[b__]] 
						:> ReleaseHold[HoldPattern[(a:>applyNiceTheorem[b])]],
						2
					]*)
	];
	geomPrint["nicethms done"(*, nicethms, thms*)];
	
	(*geomPrint["olddiag"(*,olddiag*),aaapplyTheorems[olddiag, anglecontradictionthm(*,opts*)],applyTheorems[olddiag, anglecontradictionthm(*,opts*)]];*)
	
	If[!FreeQ[#,"Contradiction"],  geomPrint["contraAA-explicit"];Return[Join[olddiag,#]]]&[applyTheorems[olddiag, justFacts = DeleteDuplicates[olddiag[[All,1]]], anglecontradictionthm(*,opts*)]];
	geomPrint["olddiag1",aapplyTheorems[olddiag, justFacts(*, randomChoice[nicethms,olddiag]*)(*,opts*)]];
	newdiag =(*CleanUpDiag@*)DeleteCases[Join[olddiag,applyTheorems[olddiag, justFacts, nicethms(*randomChoice[nicethms,olddiag]*)(*,opts*)]],geomPrint["olddiag1i90"];"Ignore"];
	
	geomPrint["newdiag"(*,newdiag*)];
	While[(*(olddiag=!=newdiag || !reducesched || ! nicethems)  && (*"getting nowhere"*) *) AbsoluteTime[]-starttime < timelimit && (If[!#,geomPrint["$MaxIterations=",stepslimit," reached"]];#)&[
				i<stepslimit 
			],
		i++;
		geomPrint["Round: ",i," number of facts: ",Length[newdiag]];
		If[Length[newdiag]>150,geomPrint["TOOOO BIGG!!!!!"]; Return[newdiag]];
		(*geomPrint["Length[newdiag]",Length[newdiag],DeleteDuplicates[newdiag[[All,1]]],justFacts2(*,DeleteDuplicates[#["Fact"]&/@newdiag]*)];*)
		(*If[!TrueQ[$AlwaysRunMaxIters] && checkCompletesched[i] && justFacts2 === DeleteDuplicates[newdiag[[All,1]]], Return[newdiag]];*) (* RUN FASTER BY KEEPING FACTS IN VARS (SINCE USED BELOW TOO)*)
		geomPrint[Length/@{olddiag,newdiag}];
		
		((*Print[#];*)If[!FreeQ[#,"Contradiction"],geomPrint["contraAA-1"]; Return[Join[olddiag,#]]])&[(*Print["contraAA",pplyTheorems[(*newdiag,*) justFacts, anglecontradictionthm(*,opts*)]];*)
			newdiag
		];
		
		geomPrint["contraPPassed"(*,knownvars,justNiceFacts//tfc*)];
		
		olddiag=newdiag;
		With[{newdiagraw = If[reducesched[i],solveEquationsAndSimplify,{(*Cases[#,HoldPattern[_ == _?(Depth[#]<2&)],2]*){},#}&][
			DeleteDuplicates[Join[olddiag(*/.knownvars*),
				applyTheorems[
					olddiag,
					If[pfFlag && nicethmsched[i], 
						justNiceFacts = SortProofs[If[knownvars===False,#,#/.knownvars]&[justFacts2=DeleteDuplicates[Select[olddiag[[All,1]],MatchQ[Head[#],Parallel|Tangent] ||FreeQ[#,_?(Head[#1]===ConstructedGeometricPoint&)]&]]]],
						justFacts = SortProofs[If[knownvars===False,#,#/.knownvars]&[justFacts2=DeleteDuplicates[olddiag[[All,1]]]]]
					],
					If[pfFlag && nicethmsched[i], nicethms(*randomChoice[nicethms,olddiag]*), thms(*randomChoice[thms,olddiag]*)](*,opts*)
				]
			], N[#1[[1]]]===N[#2[[1]]] || (Head[#1[[1]]]===Equal && N[Reverse[#1[[1]]]]===N[#2[[1]]])&]
		]},
		geomPrint["appthms-DONE", First[newdiagraw],{{}},newdiagraw[[2]], "\n\n ioiioioioiooioioioi \n",knownvars,
							"\n 99 \n",justFacts2,"\n 99 \n",If[pfFlag && nicethmsched[i], justNiceFacts,justFacts]];
		knownvars = (*If[MatchQ[#,{False,{___}}],"CONTRAdiction!!!",Rule@@@#]&@*) Replace[(*N@*)If[#==={},knownvars,#]&[Select[Replace[First[newdiagraw],False->{}], MatchQ[#,_ == (_Symbol|_?NumericQ)]&]],Equal->Rule,2,Heads->True];
		geomPrint[olddiag,"knownvars",knownvars(*rReplace[(*N@*)If[#==={},knownvars,#]&[First[newdiagraw]],Equal->Rule,2,Heads->True]*)];
		newdiag =(*CleanUpDiag@*)(*SortProofs@ -might want to do this, see overall facts structure!*)
			DeleteCases[
				Join[
					Last[newdiagraw],
					If[MatchQ[knownvars,{}|False(*have special contradiction row already*)],
						{}, 
						geomPrint[newdiagraw,Select[First[newdiagraw],FreeQ[#,ConstructedGeometricPoint[_]]&],{{}},Last[newdiagraw][[2;;,1]], "\n===\n",Complement[Select[First[newdiagraw],FreeQ[#,ConstructedGeometricPoint[_]]&], Flatten[Last[newdiagraw][[2;;,1]]], SameTest -> (N[#1]===N[#2]&)]];
						(*If[#==={},{},{(*#\[Rule]"found out! (sbsSolve system of eqns again: )"*)(*First[newdiagraw] i think*)}]&[*)
						Complement[Select[First[newdiagraw],FreeQ[#(*/.InfiniteLineThrough[{__}]\[Rule]""*),ConstructedGeometricPoint[_]]&], Flatten[Last[newdiagraw][[2;;,1]]], SameTest -> (N[#1]===N[#2]&)]
						(*]*)
					]](*/.Rule@@@First[newdiagraw] -reduces everything to True*),
				"Ignore"|(True->_)
			]; geomPrint["deleted-Ignore, now have newdiag...."]
		];
		(*DeleteDuplicates[  ,(#1["Fact"]===#2["Fact"] (*&& !FreeQ[#1,_?GenericPointQ]*))&]*)
		geomPrint[{i,"NewDiag: ",newdiag[[All,1]]//tfc}(*,newdiag*)];
		(If[!FreeQ[#,"Contradiction"],  geomPrint["contraAA-2"];Return[Join[olddiag,#]]])&[(*Print["contraAA",pplyTheorems[(*newdiag,*) justFacts, anglecontradictionthm(*,opts*)]];*)
			applyTheorems[newdiag, DeleteDuplicates[Join[justFacts,justNiceFacts]], anglecontradictionthm(*should check for other inconsistancies*)(*,opts*)]
		];
	];
	newdiag
]


Clear[delDupesOfNumbers];
delDupesOfNumbers[facts_]:= ((*Print[facts];*)(*Module[{equalNumCases = Cases[facts,HoldPattern[(angOrlen_ \[Equal] _?NumericQ)\[Rule]_]:>angOrlen]},
	DeleteCases[facts, (Alternatives@@equalNumCases \[Equal] _?(!NumericQ[#]&))\[Rule]_]
]*)
FixedPoint[
	Function[var,Replace[var,
		HoldPattern[{pre___, HoldPattern[(angOrlen_ == n_?NumericQ)->reason_], b___}] (*/; !FreeQ[{b},HoldPattern[(angOrlen == n|_?(((*Print[n,{#,!NumericQ[#]}];*)!NumericQ[#])&))->_]] - superfluous since rhs deletes them anyway*)
		:>{pre, (angOrlen == n)->reason,(*Print[{b}//tfc];*)Sequence@@DeleteCases[{b},(*HoldPattern[*)(angOrlen == (value_?(((*Print[n,{#,!NumericQ[#]}];*)#==n || !NumericQ[#])&)))->_(*]*)(*/;!NumericQ[value]*)]}]],
	facts
])


prepDatum4PF[reducedOut_] :=(reducedOut)[#]&/@{Parallel,CircleThrough,CircleArcLength,EuclideanDistance,GeometricArea,Angle}/.{_Missing->0}


randomChoice[a_List, diag_]:=
With[{l=Length[a], ro=prepDatum4PF[reduceInput[diag]]},
	With[{r = ((*Print[Row[{#, ": "<>thmlabs[[#]]}]];*)#)&[(*RandomInteger[l-1]+1*)(*Print[pf24[{thmlabs[[#]],ro}]&];*)
		$lastThmGroupApplied = First[MaximalBy[DeleteCases[Range[l-1]+1, $lastThmGroupApplied], pf2[{thmlabs[[#]],ro}]&]]
	]},
		a[[r]]
	]
];

randomChoice[a_List, l_Integer, diag_]:=
With[{ro=prepDatum4PF[reduceInput[diag]]},
	With[{r = ((*Print[Row[{#, ": "<>thmlabs[[#]]}]];*)#)&[(*RandomInteger[l-1]+1*)
		$lastThmGroupApplied = First[MaximalBy[DeleteCases[Range[l-1]+1, $lastThmGroupApplied], pf2[{thmlabs[[#]],ro}]&]]
	]},
		a[[r]]
	]
]		


(* just looks at the existing facts. This is how proofs can get out of order!!! *)

applyTheorems[diag_, facts_, thms_(*,opts*)]:=(

(*geomPrint["GOGO", #["Fact"]&/@diag,thms];*)
geomPrint["GOGO---applyTheorems-----------------------"(*,thms*)];


(*DeleteDuplicates@*)
		(*(*for ML-training*)($scoredata = Append[$scoredata, reduceInput[diag](*could speed up by reducing-as-we-go*)->thms[[1]]->Length[#]]; #)&@*)
		Select[(geomPrint["applyTheorems3"];#)&@
			Flatten[(geomPrint["applyTheorems2"];#)&@Replace[
			    (geomPrint["applyTheorems1",rReplaceList[facts, thms]];#)&[
				    ReplaceList[Flatten[facts](*diag[[All,"Fact"]]*), thms(*[[2]] - for ML*)]
				], 
				{
					HoldPattern[facs_List -> pr_] :> ((#->pr)&/@facs),
					HoldPattern[facs_List] :> (Unevaluated[Sequence@@facs])
					(*HoldPattern[Association["Fact" -> a_List, "Proof" -> p_]] :> (Association["Fact" -> #, "Proof" -> (#->p[[2]])]&/@a),
					HoldPattern[Association["Fact" -> a_List]] :> (Association["Fact" -> #]&/@a)*)
				},
				1
			]
			], 
			(#=!="Ignore"(*|$Failed, prob.*) && !MatchQ[#[[1]],(Angle[__]==_?(#==0 || #==180 &))])&
			]

)

(* possible to do faster since we know the structure ??? *)


reduceInput[diag_] := CountsBy[diag,Head[#[[1]]]&]


flip["R"] = "L";
flip["L"] = "R";


(*combine any 2 lines/points? that are equal, sort things,
enforce transitivity of parallelism, NO THESE ARE STEPS IN A PROOF!!!
delete dup end agrs 4 angles with "closest to center" rule,
align angle orders to line orders?? not now...*)
CleanUpDiag[diag_]:=
	Replace[
		SortBy[diag,Which[Head[#]===Parallel,0,Head[#]===InfiniteLineThrough,1,True,2]&],
		{
			Angle[x_,y_,w_,t___](*?(First@Sort[{x,#}]===#&)*)==a_:>
				If[First@Sort[{x,w}]===x,Angle[x,y,w,t]==a,Angle[w,y,x,t]==a]
		},
		1
	]


(* ::Subsection:: *)
(*this is what decides the proof behavior*)


applyTheorem[a__, opts:OptionsPattern[]] :=(*justApply[a, opts]*)(*applyAndPrint[a, opts]*)applyAndAddProof[a, opts](*applyAndPrintAndAddProof[a, opts]*);


(*will apply prejudiciously so proofs are as clear of "generated points" as possible
DOESNT SPEED UP, SINCE PATTERN STILL NEEDS TO MATCH. POSSIBLE TO MODIFY LHS OF RULE INSTEAD? *)
applyNiceTheorem[name_,data_,conclusion__, opts:OptionsPattern[]] := 
	If[FreeQ[{data/.{Parallel[__]->0},conclusion}, _?GenericPointQ], 
		(*If[!FreeQ[{data,conclusion},Angle[y,z,w,70,___]],geomPrint["data70: ",{data,conclusion}]]; 
		If[!FreeQ[{data,conclusion},Angle[x,z,y,90,___]],geomPrint["data90: ",{data,conclusion}]];*)
		applyTheorem[name,data,conclusion, opts], 
		"Ignore"
	]


(* ::Section:: *)
(*Collecting and displaying proofs*)


(* ::Subsection:: *)
(*ProveGeometricFacts and related functions*)


GenericPointQ = (Head[#]===ConstructedGeometricPoint)&; (* need this now? _?GenericPointQ could be _ConstructedGeometricPoint *)


initProofs[diag_] := 
(*Association["Fact"->#,"Proof"->(#->If[MatchQ[#, Parallel[InfiniteLineThrough[{_?GenericPointQ, _, _, _?GenericPointQ}]]], "implicit", "given"])]*)
(#->If[MatchQ[#, Parallel[InfiniteLineThrough[{_?GenericPointQ, _, _, _?GenericPointQ}]]], "implicit", "given"])&/@diag(*($pfs = Thread[diag->Table["given",{Length[diag]}]])*)


justApply[thmKey_String, premises_List, res_, opts:OptionsPattern[]] := res(*<|"Fact"->res|>*);

applyAndPrint[thmKey_String, premises_List, res_, opts:OptionsPattern[]] := (geomPrint[{thmKey, premises, res, opts}]; res(*<|"Fact"->res|>*))&;

applyAndAddProof[thmKey_String, premises_List, res_, opts:OptionsPattern[]]:= Module[{}, (*Print[thmKey];*)
	(*<|
	"Fact"->res,
	"Proof"->addtoProofs[thmKey, premises, res]
	|>*)addtoProofs[thmKey, premises, res, opts]
];

applyAndPrintAndAddProof[thmKey_String, premises_List, res_, opts:OptionsPattern[]]:=Module[{},
	(*geom*)Print[{thmKey,premises,res}];
	(*<|
	"Fact"->res,
	"Proof"->addtoProofs[thmKey, premises, res]
	|>*)addtoProofs[thmKey, premises, res, opts]
	
];


Clear[addtoProofs];
addtoProofs[thmKey_String, premises_List, res_, opts:OptionsPattern[]]:=((*geomPrint["addtoProofs"];*)
	(*AppendTo[$pfs,res->heldgetProof[thmKey, premises, res]]*)res->heldgetProof[thmKey, premises, res, opts])


(*
represents applying the axioms of algebra.
e.g. for diag7 where we have to use algebra as well to get answer (Angles only for now)
SHOULD be used in main loops, not getProofs.
it is now.
combine ang, len, area into a general equal Cases, maybe
*)
solveEquationsAndSimplify[pfs_]:=
	(*If[applyTheorems[newdiag, justFacts, anglecontradictionthm(*,opts*)],*)
	Module[{scn,res, oldfacts = Flatten@Replace[pfs, (l_List -> pf_):>(#->pf&/@l), {1}],
			res2, resBoth,
			resAng, resLen = {}, resArea
		},
		
		resAng = DeleteDuplicates@ReplaceList[oldfacts, {{___, HoldPattern[Equal[e__]] -> pf_, ___} /; FreeQ[{e},DeleteCases[$AllowedGeometryHeads,Angle|(*EuclideanDistance|*)GeometricPoint|Equal]] :> {Equal[e],pf}}];
		resLen = DeleteDuplicates@ReplaceList[oldfacts, {___,len1:EuclideanDistance[a_,b_]==d1_ -> pf_,___}:>{len1,pf}];
		(*resArea = ReplaceList[pfs, {___,{ang1:Angle[a_,b_,c_,d1_],_},___,{ang2:Angle[a_,b_,c_,d2_],_},___}\[RuleDelayed]{Equal[d1,d2],{ang1,ang2}}];*)
		geomPrint["resLen",(*oldfacts,*)resLen(*[[All,1]],*)(*oldfacts,"\n\n",
					ReplaceList[Flatten[pfs[[All,1]]], {{___, HoldPattern[Equal[e__]](* -> _*), ___}\[RuleDelayed]{e}}] ,
					"resLen",resLen[[All,1]],*)(*"\n\n resAng",DeleteCases[resAng[[All,1]],True]*)(*[[All,1]]*)(*,"pfs",pfs*)
				];
		
		(*explicit contradiction finder - do we still need anglecontradictionthm??*)
		scn = Scan[If[#[[1]]===False, Return[{#,Append[pfs, "Contradiction"->heldgetProof["specialcase",{#[[2,1]], #[[2,2]]},False]]}]]&, Join[resAng,resLen]];
		If[scn=!=Null,Return[scn]];
		
		(**try solving for vars, and find implicit contradictions, using Reduce[]**)
		
		(*ALGEBRA ON ANGLES*)
		geomPrint["res: ",rReduce[And@@resAng[[All,1]]]];
		res2 = TimeConstrained[Quiet@Reduce[(*SetPrecision[*)And@@DeleteCases[resAng[[All,1]],True](*,8]*),Reals],3,{}];
		If[Head[res2]===Reduce,  geomPrint["LLL::", Select[resAng[[All,1]],FreeQ[#,DeleteCases[$AllowedGeometryHeads,Angle|GeometricPoint|Equal],Heads->True]&]];
			res2 = TimeConstrained[Quiet@Reduce[(*SetPrecision[*)And@@DeleteCases[Select[resAng[[All,1]],FreeQ[#,DeleteCases[$AllowedGeometryHeads,Angle|GeometricPoint|Equal],Heads->True]&],True](*,8]*),Reals],3,{}]
		];
		geomPrint["res2ang",res2(*,pfs*)];
		If[res2===False, geomPrint["found contradiction among angles!"(*,resAng*)(*,pfs*)];
			Return[{res2,Append[pfs, "Contradiction"->heldgetProof[{"specialcase","angles"}, (*"call sbsSystemOfEquations on this",*) resAng/.{p_?GenericPointQ :>ConstructedGeometricPointinProof@@p}(*this is so the pf doesnt get deleted, its now a "proof generic point"*),"Contradiction"]]}]
		];
		
		(*ALGEBRA ON LENGTHS*)
		geomPrint["res: ",rReduce[(*SetPrecision[DeleteCases[*)
					And@@Join[
						(#>0)&/@DeleteDuplicates[Cases[resLen[[All,1]], _EuclideanDistance(*Symbol|*),3]], (*genericity conditions*)
						resLen[[All,1]]
						](*,True]*) (*&& newd > 0*)(*, 8]*), 
						Reals, Backsubstitution->True]
			];
		res = (*Rationalize@*)TimeConstrained[
			BooleanConvert[
				TimeConstrained[Quiet@Reduce[(*SetPrecision[DeleteCases[*)
					And@@Join[
						(#>0)&/@DeleteDuplicates[Cases[resLen[[All,1]], _EuclideanDistance(*Symbol|*),3]], (*genericity conditions*)
						resLen[[All,1]]
						](*,True]*) (*&& newd > 0*)(*, 8]*), 
						Reals, Backsubstitution->True],3,{}],"CNF"], 
			.03, {}]; 
		If[res===False, geomPrint["found contradiction among lengths!"(*,res*)(*,pfs*)];
			Return[{res,Append[pfs, "Contradiction"->heldgetProof[{"specialcase","lengths"}, (*"call sbsSystemOfEquations on this",*) resLen/.{p_?GenericPointQ :>ConstructedGeometricPointinProof@@p}(*this is so the pf doesnt get deleted, its now a "proof generic point"*),"Contradiction"]]}]
		];
		
		(*no contradictions, so return what we found, if anything*)
		res = Complement[Simplify/@Select[Cases[res, HoldPattern[(_ == _?NumericQ)|(_EuclideanDistance == _EuclideanDistance)|(_Angle == _Angle)], {1}], FreeQ[#,_?GenericPointQ]&], oldfacts[[All,1]], SameTest -> (N[#1]===N[#2]&)];
		res2 = Complement[Simplify/@Select[Cases[res2, HoldPattern[(_ == _?NumericQ)|(_EuclideanDistance == _EuclideanDistance)|(_Angle == _Angle)], {1}], FreeQ[#,_?GenericPointQ]&], oldfacts[[All,1]], SameTest -> (N[#1]===N[#2]&)];
		resBoth = Join[res,res2](*Complement[Simplify/@Select[Cases[{res, res2}, HoldPattern[(_ == _?NumericQ)|(_EuclideanDistance == _EuclideanDistance)|(_Angle == _Angle)], {2}], FreeQ[#,_?GenericPointQ]&], oldfacts[[All,1]], SameTest -> (N[#1]===N[#2]&)]*)(*Replace[ this, (s_Symbol \[Equal] (a_EuclideanDistance|a_Angle)) \[RuleDelayed] a \[Equal] s]*); 

		geomPrint["resBoth: ",sSelect[cCases[{res, res2}, HoldPattern[(_ == _?NumericQ)|(_EuclideanDistance == _EuclideanDistance)|(_Angle == _Angle)], {2}], FreeQ[#,_?GenericPointQ]&],(*oldfacts[[All,1]],*)"\n resBost",resBoth];
		{
			resBoth, 
			If[resBoth==={}, pfs, (*Print[":{:{{", res2];*) 
				Append[pfs, 
					((*And@@*)resBoth/.{p_?GenericPointQ :>ConstructedGeometricPointinProof@@p})
					 -> heldgetProof[
							"specialcase", (*"By algebra.\n call SBSSystemOfEquations[] on this for details:\n",*) 
							Thread[Which[
								MatchQ[res,True|{}],{"Angle","Length"}->{resAng[[All,1]],{}},
								MatchQ[res2,True|{}],{"Angle","Length"}->{{},resLen[[All,1]]},
								True, {"Angle","Length"}->{resAng[[All,1]],resLen[[All,1]]}
							]]/.{p_?GenericPointQ :>ConstructedGeometricPointinProof@@p}(*this is so the pf doesnt get deleted, its now a "proof generic point"*),
							resBoth
						]
				]
			]
		}(*;
		
		
		(*why the above again??*)
		
		(*TODO: same thing for areas,...*)
		Scan[If[#[[1]]===False, Return[Append[pfs, {"Contradiction", heldgetProof["specialcase",{#[[2,1]], #[[2,2]]},False]}]]]&, resLen];
		res2 = Reduce[And@@resLen[[All,1]]];(*geomPrint[res,res2,pfs];*)
		If[resLen===False, Return[Append[pfs, {"contradicion", getProof["specialcase", "call sbsSystemOfEquations on this", resLen]}]]];
		res2 = Cases[{res2}, _ == _?NumericQ, 1]; (*geomPrint[res,res2,pfs];*)
		If[res2==={}, pfs, Append[pfs, {And@@res2, getProof["specialcase", "call sbsSystemOfEquations on this", resLen]}]]*)
	]
	
(*no longer used, but might need to later*)
solveEquationsAndSimplifyEnd[pfs_]:=
	Module[{
			res2, 
			resAng = ReplaceList[pfs, {___,ang1:Angle[a_,b_,c_]==d1_->_,___,ang2:Angle[a_,b_,c_]==d2_->_,___}:>{Equal[d1,d2],{ang1,ang2}}],
			resLen = ReplaceList[pfs, {___,len1:EuclideanDistance[a_,b_]==d1_->_,___,len2:EuclideanDistance[a_,b_]==d2_->_,___}:>{Equal[d1,d2],{len1,len2}}],
			resArea(* = ReplaceList[pfs, {___,{ang1:Angle[a_,b_,c_,d1_],_},___,{ang2:Angle[a_,b_,c_,d2_],_},___}\[RuleDelayed]{Equal[d1,d2],{ang1,ang2}}]*)
		},geomPrint[resAng,"res2",pfs];
		Scan[If[#[[1]]===False, Return[Append[pfs, "Contradiction"->heldgetProof["specialcase",{#[[2,1]], #[[2,2]]},False]]]]&, resAng];
		res2 = Quiet@Reduce[And@@resAng[[All,1]]];geomPrint["res2",res2(*,pfs*)];
		If[resAng===False, Return[Append[pfs, "Contradiction"->heldgetProof["specialcase", resAng, "Contradiction"]]]];
		res2 = Cases[{res2}, _ == _?NumericQ, 2]; geomPrint["res2",res2(*,pfs*)]; 
		
		If[res2==={}, pfs, Append[pfs, And@@res2-> heldgetProof["specialcase", resAng, "Contradiction"]]](*;
		
		(*TODO: same thing for lengths, and areas*)
		Scan[If[#[[1]]===False, Return[Append[pfs, {"Contradiction", heldgetProof["specialcase",{#[[2,1]], #[[2,2]]},False]}]]]&, resLen];
		res2 = Reduce[And@@resLen[[All,1]]];(*geomPrint[res,res2,pfs];*)
		If[resLen===False, Return[Append[pfs, {"contradicion", getProof["specialcase", "call sbsSystemOfEquations on this", resLen]}]]];
		res2 = Cases[{res2}, _ == _?NumericQ, 1]; (*geomPrint[res,res2,pfs];*)
		If[res2==={}, pfs, Append[pfs, {And@@res2, getProof["specialcase", "call sbsSystemOfEquations on this", resLen]}]]*)
	];


Options[ProveGeometricFacts] = {"UseTheorems" -> Automatic, "StepsLimit"-> $MaxIterations, "TimeLimit" -> $TotalTimeLimit, "TargetFact"->"All"};
Options[GetAllProofsFromDiag] = Options[ProveGeometricFacts];

ProveGeometricFacts[GeometricScene[diag_List]|diag_List] := ProveGeometricFacts[diag, fixedthms]

ProveGeometricFacts[diag_, opts:OptionsPattern[]]/;ByteCount[{opts}]<233(*VectorQ[{opts},Head[#]===Rule&]*) := (*THIS IS A HACK TO KEEP THMS FROM BEING THOUGHT AS OPTIONS*)
	ProveGeometricFacts[diag, fixedthms, opts]

ProveGeometricFacts[GeometricScene[diag_List]|diag_List, thms_List, opts:OptionsPattern[]] := Module[{res, pruned, includeMultipleResultsQ, restrictedthms},
	includeMultipleResultsQ = True(*OptionValue*);
	
	(*prepare the theorems to be used*)(*Print["::::::::"];*)
	restrictedthms = If[#=!=Automatic,
						If[SubsetQ[thmlabs,#],Join@@(#/.thms),#],
						Switch[DeleteDuplicates[Head/@diag],
							{Parallel,Angle}, geomPrint["LLLL:"];"angle thms"/.thms,
							{Parallel,Angle,CircleThrough,CircleArcLength}, Join@@({"angle thms","circ thms"}/.thms),
							_, Join@@(thms[[All,2]])
						]
					]&[OptionValue[ProveGeometricFacts,opts,"UseTheorems"]];
	restrictedthms = DeleteCases[restrictedthms,_String];

	(*prepare the diagram*)
	(*diags = *)initProofs[diag];
	
	(*get the proofs*)(*Print[vGetAllProofsFromDiag[diag, restrictedthms, opts (*, "mode"->applyAndAddProof, includeMultipleResultsQ \[Rule]...*)]];*)
	res = GetAllProofsFromDiag[diag, restrictedthms, opts (*, "mode"->applyAndAddProof, includeMultipleResultsQ \[Rule]...*)]; 
	geomPrint["pre-final result",res[[All,1]]];
	res = delDupesOfNumbers@res;
	geomPrint["done with proving, now formatting....."];
	geomPrint[gGetAllProofsFromDiag[diag, restrictedthms, opts (*, "mode"->applyAndAddProof, includeMultipleResultsQ \[Rule]...*)],res];
	
	GeometricProofObject[{
		"TwoColumnProof" ->
		Grid[Join[{{Style["Fact",Bold],Style["Reason",Bold]}},
				tfc/@(
				List@@@(*solveEquationsAndSimplifyEnd[*)
				(pruned = Replace[PruneToDesired[(*(Print[#];#)&@*)
					DeleteDuplicates[
						Cases[(*use more Replce[] her to sdp up??*)
							res /. InfiniteLineThrough[{a__}]:>InfiniteLineThrough[DeleteCases[{a},_?GenericPointQ]],
							_?(#[[2]]=!="implicit" && FreeQ[#(*[[1]]*),_?GenericPointQ]&),
							1
						],
						If[Head[#1[[1]]]===Angle && Head[#2[[1]]]===Angle, #1[[1,;;If[includeMultipleResultsQ,4,3]]]===#2[[1,;;If[includeMultipleResultsQ,4,3]]], #1[[1]]===#2[[1]] || (Head[#1[[1]]]===Head[#2[[1]]]===Equal && #1[[1,1]]===#2[[1,1]] && #1[[1,2]]==#2[[1,2]])(* #1[[1]]==#2[[1]] -works but not sure about *)]&
					],
					OptionValue[ProveGeometricFacts,opts,"TargetFact"]
				],({a__}->(pf:heldgetProof[__])) :> Column[{a}]->pf,3])/. heldgetProof->(*held*)getProof
				)
			],
			Dividers->{{2->Red,-2->Blue},{2->Red,-2->Blue}},
			Frame->All
		],
		"ComputableProof" -> res,
		"ProofNetwork" -> ProofNetwork[pruned],
		"PlaintextProof" -> "coming in the future!"
	}]
]


GeometricProofObject[a___]["TwoColumnProof"] := {a}[[1,1,2]]
GeometricProofObject[a___]["ComputableProof"] := {a}[[1,2,2]]
GeometricProofObject[a___]["ProofNetwork"] := {a}[[1,3,2]]
GeometricProofObject[a___]["PlaintextProof"] := {a}[[1,4,2]]


(* ::Subsection:: *)
(*"TargetFact", proof networks,...*)


(* ::Input:: *)
(*(*dd={<|"p"->31,"f"->42|>,<|"p"->3,"f"->44|>};*)*)
(*(*dd[[All,"f"]]*)*)


(*works on list of proofs or just facts*)
SortProofs[diag_] := 
SortBy[diag,
	Switch[If[MatchQ[Head[#],Rule|Equal],Head[#[[1]]],Head[#]],
		Parallel, 1,
		Tangent, 1.5,
		CircleThrough, 2,
		EuclideanDistance, 3,
		GeometricArea, 4,
		Angle, 5
		
	]&
]


(* TODO: when there's a Contradiction, 
this deletes statements starting at the penultimate, until a statement found in the Contradiction is reached, 
or: a minimum argument to the contradiction is reached *)
PruneToContradiction[diag_]:=Module[{},
	diag
]


(* when there's a Desired Fact pattern given by user, and we've found/proved it ,
this deletes statements starting at the penultimate, until a minimum argument to the fact is reached *)

(*GENERAL IDEA: get dep facts recursively back to givens, one layer at a time. stop when a branch (tree candidate, really) reaches all givens
BUT actually this isn't nec., since there is only one set of facts that lead to each fact (one hyperedge)
because that is how we constructed the set of proofs
*)
ProveGeometricFacts::noproof = "No synthetic proof found for `1`. \n Returning related proved facts";

PruneToDesired[diag_, "All"] := diag
(*This version doesn't use a hypergraph structure, but should be OK as most diags are small*)
PruneToDesired[thediag_, fact_(*could be a pattern*)]:=
	Module[{diag = Replace[thediag, (Parallel[lines__]->reason_) :> ((*Print["LINES:",lines];*)Unevaluated[Sequence@@Join[{Parallel[lines]->reason},#->reason&/@{lines}]]),1],
		hypergraph, reasonsforlastlayer, doingalready={}, posRules
		},
		
		posRules = Thread[diag->Range[Length[diag]]]; (*we can assume unique*)
		geomPrint["final diag to prune: ", diag];
		reasonsforlastlayer=Cases[diag, HoldPattern[({___,#,___}|#)->_]&[fact](*HoldPattern[heldgetProof[__]]*), 1, 1];
		geomPrint[cases["diag...", cCases[diag, HoldPattern[({___,#,___}|#)->_]&[fact](*HoldPattern[heldgetProof[__]]*), 1, 1], 1, 1]];
		If[reasonsforlastlayer==={}, Message[ProveGeometricFacts::noproof, fact]; Return[diag]];
		hypergraph=reasonsforlastlayer;
		
		geomPrint["toWhile",reasonsforlastlayer];
		If[!FreeQ[reasonsforlastlayer[[1,2,1]],"specialcase"], geomPrint["algebra proof!!!"];
			reasonsforlastlayer = 
				reasonsforlastlayer/.{HoldPattern[{"Angle"->as_,"Length"->ls_}]:>Select[(*Echo@*)If[FreeQ[fact,EuclideanDistance], as,ls], Depth[#]<6 && FreeQ[#,ConstructedGeometricPointinProof]&]}
		];
		geomPrint["toWhile2",reasonsforlastlayer];
		
		While[!MatchQ[DeleteDuplicates[reasonsforlastlayer[[All,2]]],{}|{"given"}],
			geomPrint["now looking for:  ", reasonsforlastlayer[[All,2]],
										DeleteCases[reasonsforlastlayer[[All,2]] (*/.("DisplayProofData"\[Rule]_)\[Rule]""*),"given"],
										Flatten[DeleteCases[reasonsforlastlayer[[All,2]] (*/.("DisplayProofData"\[Rule]_)\[Rule]""*),"given"][[All,2]],1], 
										DeleteDuplicates[DeleteCases[Flatten[DeleteCases[reasonsforlastlayer[[All,2]] (*/.("DisplayProofData"\[Rule]_)\[Rule]""*),"given"][[All,2]],1],Alternatives@@Join[reasonsforlastlayer[[All,1]],doingalready]]]];
			doingalready = Join[reasonsforlastlayer[[All,1]],doingalready];
			reasonsforlastlayer = Cases[
				diag(*could continually trim this back using reasonsforlastlayer, for speed*),
				HoldPattern[#->_]&[Alternatives@@DeleteDuplicates[DeleteCases[Flatten[DeleteCases[reasonsforlastlayer[[All,2]] (*/.("DisplayProofData"\[Rule]_)\[Rule]""*),"given"][[All,2]],2,List],Alternatives@@doingalready]]]
			];
			geomPrint["reasonsforlastlayer",reasonsforlastlayer[[All,2]](*DeleteDuplicates[DeleteCases[reasonsforlastlayer[[All,2]],"given"][[All,2]]]*)];
			hypergraph = Join[reasonsforlastlayer, hypergraph];
		];
		
		geomPrint["hypergraph",hypergraph];
		SortBy[DeleteDuplicates[hypergraph],Replace[#,posRules]&]
	]


(* a tree is a better form for looking up complete proofs back to given assumptions *)
(*alt.name: ProofListToTreeForm[pfs_List]:=pfs*)

ProofNetwork[diag_, "RunProver"->True]:=ProofNetwork[ProveGeometricFacts[diag,fixedthms][[1,2,2]]]

ProofNetwork[diag_]:=
Module[{g11,sssun,vvc},
		
	sssun = (*ReplacePart[#, 1 \[Rule] tfc[#[[1]]]]& /@*) Select[(*ProveGeometricFacts[diag,fixedthms]*)diag,FreeQ[#/.InfiniteLineThrough[{__}]->"line",ConstructedGeometricPoint]&];
	
	g11 = Graph[Flatten[Function[pfstep,
	Which[
		pfstep[[2]]==="implicit",{},
		pfstep[[2]]==="given",{DirectedEdge["given",pfstep[[1]]]},
		True,DirectedEdge[#,pfstep[[1]]]&/@(*tfc/@*)Flatten[(*DO THIS WITH "DisplayProofData" !!!!*)Replace[pfstep[[2,2]], {"Angle"->a_,"Length"->b_}:>((*Print[a,b];*)Join@@{a,b})], 1, List]
	]
	]/@sssun](*,
	VertexLabels\[Rule]labels*),AspectRatio->1,GraphLayout->"LayeredEmbedding"(*{"VertexLayout"->"LayeredEmbedding","PackingLayout"->"LayeredLeft"}*)(*"LayeredEmbedding"*)(*ImageSize\[Rule]1080,*)
	];
	vvc=RotationTransform[84 Degree]/@Last@Last@AbsoluteOptions[g11,VertexCoordinates];(*Print[vvc];*)
	
With[{ssun=sssun,g1=g11,vc=vvc, indices=Join[{"given"->"v0"},Table[VertexList[g11][[i]]->(i-1),{i,VertexCount[g11]}]]},Manipulate[
If[!MatchQ[labels,"Name"|None|indices|Placed["Name",Tooltip]],labels=None];
	Graph[If[labels===indices, Identity, myMakeBoxes]@Flatten[Function[pfstep,
	Which[
		pfstep[[2]]==="implicit",{},
		pfstep[[2]]==="given",{Style[DirectedEdge["given",pfstep[[1]]],{Red,Dashed}]},
		True,DirectedEdge[#,pfstep[[1]]]&/@Flatten[(*DO THIS WITH "DisplayProofData" !!!!*)Replace[pfstep[[2,2]], {"Angle"->a_,"Length"->b_}:>((*Print[a,b];*){a,b})], 1, List]
	]
	]/@ssun],
	VertexLabels->labels,VertexCoordinates->vc],
	{labels,{"Name"->"facts",Placed["Name",Tooltip]->"tooltips",None->"no labels",indices->"indices"}}(*,{}*)]
]
]


(* ::Subsection:: *)
(*proof StringTemplate's for each theorem (or theorem-class)*)


GeometricTraditionalForm = tfc = myMakeBoxes;
myMakeBoxes[a_] := myMakeBoxes[a,TraditionalForm];
myMakeBoxes["Contradiction"] := Grid[{{"Contradiction"}},Frame->All,FrameStyle->Red]
myMakeBoxes[a_, TraditionalForm] := a/.{h_?(MatchQ[Head[#],$AllowedGeometryHeads]&) :> myMakeBoxes[h, TraditionalForm]};
(*myMakeBoxes[g_Grid] := g/.Rule[];*)

myMakeBoxes[expr_ -> r_, TraditionalForm] := myMakeBoxes[expr, TraditionalForm] -> r
myMakeBoxes[expr_ == a_, TraditionalForm] := Row[{myMakeBoxes[expr, TraditionalForm], " \[LongEqual] ", myMakeBoxes[a, TraditionalForm]}]
myMakeBoxes[a_,___] := a


formatForStringTemplate[a_] :=
	If[FreeQ[a,$AllowedGeometryHeads],
		ToString[a, FormatType->StandardForm], 
		a/.{g_?(MatchQ[Head[#],$AllowedGeometryHeads]&) :> (myMakeBoxes[#,TraditionalForm]&[g])}
	]
	
geometryToString[a_] := 
	If[FreeQ[a,$AllowedGeometryHeads],
		ToString[a, FormatType->StandardForm],
		ToString[a/.{g_Angle :> (myMakeBoxes[#,TraditionalForm]&[g])},FormatType->StandardForm]]


Clear[getProof]

Options[getProof] = {"DisplayProofData"->None};

(*better idea:
t = Row[{"This planet is ", TemplateSlot["planet"]}];
TemplateObject[t][<|"planet" \[Rule] "Mars"|>]
*)

getProof[name_, givens_, res_, ops:OptionsPattern[]] /; (OptionValue[getProof,{ops},"DisplayProofData"]=!=None)(*!FreeQ[{ops},HoldPattern["DisplayProofData"\[Rule]_]]*) := 
	Module[{},
		getProof[name, OptionValue[getProof,{ops},"DisplayProofData"], res]
	]

getProof["aban1"|"aban2", {l_,nn_==na_}, Angle[w_,c_,z_,t___]==a_] := 
	Row@TemplateApply[StringTemplate["Since `1` are on a line, angle `2` is just the angle `3` by another name, which is `4` degrees", CombinerFunction -> Identity, InsertionFunction-> TraditionalForm],
	{
		myMakeBoxes[l,TraditionalForm],
		myMakeBoxes[#,TraditionalForm]&[Angle[w,c,z]],
		myMakeBoxes[#,TraditionalForm]&[nn[[1;;3]]],
		a
	}
	]
getProof["tri1", {a1_==a_,a2_==b_}, a3_==c_] := 
	StringTemplate["Since `1` \[LongEqual] `2` degrees and `3` \[LongEqual] `4` degrees, `5` \[LongEqual] `6` degrees because these form a triangle"][
		If[FreeQ[a1,$AllowedGeometryHeads],ToString[a1, FormatType->TraditionalForm],ToString[a1/.{g_Angle :> (myMakeBoxes[#,TraditionalForm]&[g])},FormatType->StandardForm]],
		If[FreeQ[a,$AllowedGeometryHeads],ToString[a, FormatType->TraditionalForm], ToString[a/.{g_Angle :> (myMakeBoxes[#,TraditionalForm]&[g])},FormatType->StandardForm]],
		If[FreeQ[a2,$AllowedGeometryHeads],ToString[a2, FormatType->TraditionalForm],ToString[a2/.{g_Angle :> (myMakeBoxes[#,TraditionalForm]&[g])},FormatType->StandardForm]],
		If[FreeQ[b,$AllowedGeometryHeads],ToString[b, FormatType->StandardForm],ToString[b/.{g_Angle :> (myMakeBoxes[#,TraditionalForm]&[g])},FormatType->StandardForm]],
		If[FreeQ[a3,$AllowedGeometryHeads],ToString[a3, FormatType->StandardForm],ToString[a3/.{g_Angle :> (myMakeBoxes[#,TraditionalForm]&[g])},FormatType->StandardForm]],
		If[FreeQ[c,$AllowedGeometryHeads],ToString[c, FormatType->StandardForm],ToString[c/.{g_Angle :> (myMakeBoxes[#,TraditionalForm]&[g])},FormatType->StandardForm]]
	]
getProof["add1", {a1_==a_,a2_==b_}, a3_==c_] := 
	StringTemplate["By angle addition, since `1` is `2` degrees and `3` is `4` degrees, `5` is `6` degrees"][
		myMakeBoxes[#,TraditionalForm]&[a1[[1;;3]]], (*Print["ppp------p0o"];*)
		If[FreeQ[a,$AllowedGeometryHeads],ToString[a, FormatType->TraditionalForm], ToString[a/.{g_Angle :> (myMakeBoxes[#,TraditionalForm]&[g])},FormatType->StandardForm]],
		myMakeBoxes[#,TraditionalForm]&[a2[[1;;3]]],
		If[FreeQ[b,$AllowedGeometryHeads],ToString[b, FormatType->StandardForm],ToString[b/.{g_Angle :> (myMakeBoxes[#,TraditionalForm]&[g])},FormatType->StandardForm]],
		myMakeBoxes[#,TraditionalForm]&[a3[[1;;3]]],
		If[FreeQ[c,$AllowedGeometryHeads],ToString[c, FormatType->StandardForm],ToString[c/.{g_Angle :> (myMakeBoxes[#,TraditionalForm]&[g])},FormatType->StandardForm]]	]

getProof["Supp1"|"Supp2"|"Supp3"|"Supp4", {s1_,s2_,s3_==sa_}, Angle[w_,c_,z_,t___]==a_] := 
	StringTemplate["`2` is the supplement angle to `1`, which is `3` degrees"][
		myMakeBoxes[#,TraditionalForm]&[s3[[1;;3]]],
		myMakeBoxes[#,TraditionalForm]&[Angle[w,c,z]],
		ToString[sa/.{g_Angle :> (myMakeBoxes[#,TraditionalForm]&[g])}, FormatType->StandardForm]
	]
getProof[thm:"ca1"|"ca2", {l1_,l2_,ang_==aa_,___},Angle[w_,c_,z_,t___]==a_] := 
	Row@TemplateApply[StringTemplate["Since `3` and `4` are parallel lines, `2` is `5` `1`", CombinerFunction -> Identity, InsertionFunction-> TraditionalForm],
	{
		myMakeBoxes[#,TraditionalForm]&[ang[[1;;3]]],
		myMakeBoxes[#,TraditionalForm]&[Angle[w,c,z],TraditionalForm], (*Print[InfiniteLineThrough@@DeleteCases[List@@l1,_?GenericPointQ(*"gp"~~*)]];*)
		myMakeBoxes[l1,TraditionalForm](*DeleteCases[First/@List@@l1,_?GenericPointQ(*"gp"~~*)]*),
		myMakeBoxes[l2,TraditionalForm],
		If[thm==="ca1","equal to", "the supplement of"]
		}]

(* oldest cong/sim: case of two triangles sharing one side *)
getProof["cong1",HoldPattern@{EuclideanDistance[(*p1_,p3*)_,_]==a_,EuclideanDistance[(*p1_,p4*)_,_]==a_,
					Angle[(*p3_,p1_,p2*)ps1__]==s_,Angle[(*p2_,p1_,p4*)ps2__]==s_}, result_]:=
(*result: {Angle[p1,p2,p3,"ang-p1-p2-p3"],Angle[p4,p2,p1,"ang-p1-p2-p3"],Angle[p2,p3,p1,"ang-p2-p3-p1"],Angle[p1,p4,p2,"ang-p2-p3-p1"],EuclideanDistance[p2,p3,"dist-p2-p3"],EuclideanDistance[p2,p4,"dist-p2-p3"]}*)
(*StringTemplate["Since both `1` and `2` contain an angle of `3` between two sides of equal length (`4`, and the shared side from `5` to `6`), these are congruent triangles, (by the side-angle-side postulate). Therefore the other corresponding lengths and angles are equal as well."]*)
StringTemplate["Since both `1` and `2` contain an angle of `3` between two sides, each of the same length as the corresponding side (`4` in one case, and the shared side is the other), these are congruent triangles, (by the side-angle-side postulate). Therefore the other corresponding lengths and angles are equal as well."][		
		myMakeBoxes[#,TraditionalForm]&[Triangle[{ps1}]],
		myMakeBoxes[#,TraditionalForm]&[Triangle[{ps2}]],
		ToString[s, FormatType->StandardForm],
		ToString[a, FormatType->StandardForm](*,
		myMakeBoxes[p1,TraditionalForm],
		myMakeBoxes[p2,TraditionalForm]*)
	]
	
getProof["similar1", {result___},___(*, "DisplayProofData"\[Rule]dpdat_*)]:=
(*result: {Angle[p1,p2,p3,"ang-p1-p2-p3"],Angle[p4,p2,p1,"ang-p1-p2-p3"],Angle[p2,p3,p1,"ang-p2-p3-p1"],Angle[p1,p4,p2,"ang-p2-p3-p1"],EuclideanDistance[p2,p3,"dist-p2-p3"],EuclideanDistance[p2,p4,"dist-p2-p3"]}*)
StringTemplate["`1` is similar to `2`, since they have two angles in common (of `3` and `4` degrees)"][geomPrint["simi 1 getpf ",tfc/@result[[1]]];
(*Print["similar1:  ", {result}];*)
		myMakeBoxes[#,TraditionalForm]&[Triangle[{result}[[1]]]],
		myMakeBoxes[#,TraditionalForm]&[Triangle[{result}[[2]]]],
		formatForStringTemplate[{result}[[-1,1]]],
		formatForStringTemplate[{result}[[-1,2]]]
		(*myMakeBoxes[p1,TraditionalForm],
		myMakeBoxes[p2,TraditionalForm]*)
	]
	
	
(*should be 2 cases (fogrot circ inside circ case) *)
getProof["circtang", {CircleThrough[l1_,cen1_,r1_], CircleThrough[l2_,cen2_,r2_]}, EuclideanDistance[cen1_,cen2_]==r_] := 
	StringTemplate["Since the circle at `1` with radius `2` and the circle at `3` with radius `4` are tangent, the distance between `1` and `3` is the sum of these radii, `5`"][
		myMakeBoxes[cen1,TraditionalForm],
		geometryToString[r1],
		myMakeBoxes[cen2,TraditionalForm],
		geometryToString[r2],
		geometryToString[r]
	]

getProof["circsubtend1a", {CircleThrough[l1_,cen1_,r1_], ang1:Angle[__,a_,t___]==_}, ang:Angle[_,_,___]==b_] := 
	StringTemplate["Since inscribed angles subtending the opposite (complementary) circular arc as a central angle measure 180 - (half of the central angle), `1` =  180 - (`2`/2) = `3`."][
		myMakeBoxes[#,TraditionalForm]&[ang[[1,1;;3]]],
		myMakeBoxes[#,TraditionalForm]&[ang1[[1,1;;3]]],
		geometryToString[b]
	]
getProof["circsubtend1b", {CircleThrough[l1_,cen1_,r1_], ang1_Angle==a_}, ang_Angle==b_] := 
	StringTemplate["Since inscribed angles subtending the same circular arc as a central angle measure half of the central angle, `1` = (`2`/2) = `3`."][
		myMakeBoxes[#,TraditionalForm]&[ang],
		myMakeBoxes[#,TraditionalForm]&[ang1],
		geometryToString[b]
	]
	
getProof["circsubtend2", {CircleThrough[l1_,cen1_,r1_], ang1:Angle[__,a_,t___]==_}, ang:Angle[__,b_,t___]==_] := 
	StringTemplate["Since central angles are twice the measure of inscribed angles subtending the same circular arc, and `1`"][myMakeBoxes[#,TraditionalForm]&[ang1]]

(*getProof["to-circ-arc",{CircleThrough[{"p","v","w"},"c",5],Angle["p","c","w",39]},CircleArcLength["c",{"p","w"},39/2]]*)
getProof["to-circ-arc", {circ:CircleThrough[__,c_,r_], (a:Angle[x_,c_,y_])==ang_}, arc:CircleArcLength[c_,(*r_,*){x_, y_}, ang_] == arclen_] :=
	StringTemplate["Since the arc length along a circle is equal to the radius times the central angle subtending the arc (in radians), the arc length from `1` to `2` is `3` \[Times] `4` \[Times] (\[Pi]/180) = `5`"][
		myMakeBoxes[x,TraditionalForm],
		myMakeBoxes[y,TraditionalForm],
		geometryToString[ang],
		geometryToString[r],
		geometryToString[arclen]
	]
getProof["from-circ-arc", {circ:CircleThrough[__,c_,r_], arc:CircleArcLength[c_,(*r_,*){x_, y_}, ang_, len_]}, ang:Angle[x_,c_,y_,a_]] :=
	If[NumericQ[len]  || !NumericQ[ang],
		StringTemplate["Since the central angle subtending an arc of a circle is (radius)/(length of arc), the central angle  `1` measures (`2`) / (`3` \[Pi]/180) = `4` degrees"][
			myMakeBoxes[#,TraditionalForm]&[ang[[1;;3]]],
			geometryToString[r],
			geometryToString[len],
			geometryToString[a]
		],
		(*kind of redundant def., but might need*)
		StringTemplate["The central angle subtending the arc is equal to the 'angle' of the arc it subtends, and `1`"][
			myMakeBoxes[#,TraditionalForm]&[arc](*,
			ToString[ang, FormatType->StandardForm]*)
		]
	]
	
getProof["circrad", {CircleThrough[___,c_,r_]}, len:EuclideanDistance[c_, pt_]==r_|EuclideanDistance[pt_, c_]==r_] :=
	StringTemplate["Since `4` is a point on the circle and radius `5` centered at `3`, `1` == `2`"][
		myMakeBoxes[#,TraditionalForm]&[len[[1]]],
		len[[2]],
		myMakeBoxes[c,TraditionalForm],
		myMakeBoxes[pt,TraditionalForm],
		geometryToString[r]
	]
	
getProof["circ-tang-lengths",{l1_InfiniteLineThrough,l2_InfiniteLineThrough,c:CircleThrough[__,cen_,_],(glen:EuclideanDistance[_,__])==l_}, (len:EuclideanDistance[_,_])==l_] :=
	Row@TemplateApply[StringTemplate["Since both `1` and `2` are line segments tangent to the `3` through the same point `4`, they have equal lengths, `5`", CombinerFunction -> Identity, InsertionFunction-> TraditionalForm],
		{l1(*myMakeBoxes[#,TraditionalForm]&[l1]*),
		l2,
		myMakeBoxes[c,TraditionalForm],
		First[Intersection[glen,len]],
		l}
	]

getProof["tri-from-area1", {EuclideanDistance[x_,w_]==len_|EuclideanDistance[w_,x_]==len_, (a:GeometricArea[__(*{y_,z_,x_}*)]) == area_}, EuclideanDistance[y_,z_]==reslen_|EuclideanDistance[z_,y_]==reslen_] :=
	StringTemplate["Since `1` \[LongEqual] `2`, and the segment from `3` to `4` is a (perpendicular) altitude/height of this triangle of length `5`, the length of the corresponding base is `6`"][
		myMakeBoxes[a,TraditionalForm],
		formatForStringTemplate[area],
		myMakeBoxes[x,TraditionalForm],
		myMakeBoxes[w,TraditionalForm],
		formatForStringTemplate[len],
		formatForStringTemplate[reslen]
	]
getProof["tri-to-area", {l1:(EuclideanDistance[(*x_,w*)_,__]==_), l2:(EuclideanDistance[(*z_,y*)_,__]==_), Angle[x_,w_,z_]==_}, (tri:GeometricArea[__])==area_]:=
	StringTemplate["Since `1` \[LongEqual] `2`, and `3` \[LongEqual] `4` is a (perpendicular) altitude/height of this triangle, `5` \[LongEqual] `6` "][
		myMakeBoxes[#,TraditionalForm]&[l1[[1]]],
		formatForStringTemplate[l1[[2]]],
		myMakeBoxes[#,TraditionalForm]&[l2[[1]]],
		formatForStringTemplate[l2[[2]]],
		(*myMakeBoxes[tri,TraditionalForm]*)(*Print[tri//FullForm];*)
		myMakeBoxes[tri,TraditionalForm],
		formatForStringTemplate[area]
	]
	
getProof["pythag-hypot",{ang_,len1_,len2_}, len_] :=
	StringTemplate["Since `1` = `2`, `3` = `4`, and the angle between these segments is 90 degrees, `5` = `6` by the pythagorean theorem"][
		myMakeBoxes[#,TraditionalForm]&[len1[[1]]],
		formatForStringTemplate[len1[[2]]],
		myMakeBoxes[#,TraditionalForm]&[len2[[1]]],
		formatForStringTemplate[len2[[2]]],
		myMakeBoxes[#,TraditionalForm]&[len[[1]]],
		formatForStringTemplate[len[[2]]]
	]
	
getProof["pythag-side",{ang_ == val_,len1_,len2_}, len_] := ((*Print[ggetProof["pythag-side",{ang == val,len1,len2}, len]];*)
	StringTemplate["Since `1` = `2`, `3` = `4` and these form two sides of a right triangle (since `5` = `6`), `7`==`8` by the pythagorean theorem"][
		myMakeBoxes[#,TraditionalForm]&[len1[[1]]],
		formatForStringTemplate[len1[[2]]],
		myMakeBoxes[#,TraditionalForm]&[len2[[1]]],
		formatForStringTemplate[len2[[2]]],
		myMakeBoxes[#,TraditionalForm]&[ang(*[[1;;3]]*)],
		formatForStringTemplate[val],
		myMakeBoxes[#,TraditionalForm]&[len[[1]]],
		formatForStringTemplate[len[[2]]]
	])

getProof[tt:"len1"|"len2",{{p1_,p2_,p3_}, len1_, len2_}, len_] :=((*STILL PRINTS IN DECIMAL FORM SINCE StringTemplate ALWAYS DOES!!  : Print[{len1,99,len2,len,StringTemplate["Since `1`"][len1[[2]]]}];*)
	StringTemplate["Since `1` \[LongEqual] `2`, `3` \[LongEqual] `4`, and the fact that `5`, `6`, and `7` lie on a line (in that order)"][
		myMakeBoxes[#,TraditionalForm]&[len1[[1]]],
		formatForStringTemplate[len1[[2]]],
		myMakeBoxes[#,TraditionalForm]&[len2[[1]]],
		formatForStringTemplate[len2[[2]]],
		myMakeBoxes[p1,TraditionalForm],
		myMakeBoxes[p2,TraditionalForm],
		myMakeBoxes[p3,TraditionalForm](*,tt*)
	])
	
getProof["area-add",{plusminus_String, {p__(*{w___},{x___},{y___},{z___},{lmor___},{rmor___}*)}, a1_, a2_}(*{a1:GeometricArea[___]\[Equal]ar1_, a2:GeometricArea[___]\[Equal]ar2_}*), a3:GeometricArea[___]==ar3_] := 
	StringTemplate["Since `1` = `2` and `3` = `4`, and these regions together form the `5` `6`, `7` = `8`"][
		myMakeBoxes[#,TraditionalForm]&[a1[[1]]],
		a1[[2]],
		myMakeBoxes[#,TraditionalForm]&[a2[[1]]],
		a2[[2]],
		Switch[Length[a3[[1,1]]], 3, "triangle"(*but how?*), 4, "quadrilateral", _, "polygon"],
		(*myMakeBoxes[#,TraditionalForm]&*)Row[ToString/@First/@Flatten@(*{{"f"}}*)(*Flatten[list]*){p}],
		myMakeBoxes[#,TraditionalForm]&[a3[[1]]],
		a3[[2]]
	]	
	
getProof["area-subtract",{{{w___},{x___},{y___},{z___},{mor___}}, a1_, a2_}, a3:GeometricArea[___]==ar3_] := 
	StringTemplate["Since `1` = `2` and `3` = `4`, and the difference of these regions is the `5` `6`, `7` = `8`"][
		myMakeBoxes[#,TraditionalForm]&[a1[[1]]],
		a1[[2]],
		myMakeBoxes[#,TraditionalForm]&[a2[[1]]],
		a2[[2]],
		Switch[Length[a3[[1,1]]], 3, "triangle"(*but how?*), 4, "quadrilateral", _, "polygon"],
		(*myMakeBoxes[#,TraditionalForm]&*)Row[ToString/@First/@{w,x,y,z,mor}],
		myMakeBoxes[#,TraditionalForm]&[a3[[1]]],
		(*myMakeBoxes[#,TraditionalForm]&*)TraditionalForm[a3[[2]]]
	]	

getProof["SegsTweenParall1",{l1:EuclideanDistance[_,__],l2:EuclideanDistance[_,__],ang:Angle[___]},resang:Angle[___]] :=
	Which[ang[[4]]==90 Degree (* \[Equal], since could be Pi/2?*),
		StringTemplate["SegsTweenParall1, right angle..."][
			
		],
		True,
		StringTemplate["SegsTweenParall1 general..."][
			
		]
	]

(*TODO: should specify which lines are parallel, and/or at least the angles we are using*)
getProof["parallelsegmentLen",{gp1_,gp2_,len1_==l_},len_] :=
	StringTemplate["Parallel segments between parallel lines have the same length, and we know `1` == `2`, `3` == `2` also"][
		myMakeBoxes[len1,TraditionalForm],
		l,
		myMakeBoxes[len,TraditionalForm]
	]
		
(**)
getProof["SegsTweenParall2",{l:EuclideanDistance[_,__]==len1_, ang1_ == val1_?(#==90&), ang2_ == val2_?(#==90&)}, resl:EuclideanDistance[_,__]==len_] :=
	(*StringTemplate["Since `1` is a segment another perpendicular segment joining the parallel lines given by "][
		myMakeBoxes[#,TraditionalForm]&[resl[[1]]],
		
	]*)getProof["parallelsegmentLen",{ang1,ang2,l},resl[[1]]]
	
	(*getProof("trig-or-special-triangles",{distance(p1, p4) = 2,\[Angle]p4p2p1 = 90 degrees,\[Angle]p2p1p4 = 32 degrees},{distance(p1, p2) = 1.696096192312852`,distance(p2, p4) = 1.0598385284664098`})*)
getProof["trig-or-special-triangles",{EuclideanDistance[p1_,p2_]==a_|EuclideanDistance[p2_,p1_]==a_, ang1:Angle[_,_,_,b_,___], ang:Angle[_,_,_,c_,___]}, {EuclideanDistance[x_,p1_]==len1_|EuclideanDistance[p1_,x_]==len1_, EuclideanDistance[x_,p2_]==len2_|EuclideanDistance[p2_,x_]==len2_}] :=
	StringTemplate["trig-or-special-triangles"][
		
	](*getProof("trig-or-special-triangles",{distance(p1, p4) = 2,\[Angle]p4p2p1 = 90 degrees,\[Angle]p2p1p4 = 32 degrees},{distance(p1, p2) = 1.696096192312852`,distance(p2, p4) = 1.0598385284664098`})*)
	
getProof["fromisoceleslen",__] := (*StringTemplate@*)"angles opposite equal sides of an isoceles triangle are also equal";


getProof["specialcase",{d1_==a1_,d2_==a2_}, False|"Contradiction"] := 
	StringTemplate["Since `1` = `2` and `3` = `4` cannot both be true."][
		myMakeBoxes[d1,TraditionalForm],
		myMakeBoxes[a1,TraditionalForm],
		myMakeBoxes[d2,TraditionalForm],
		myMakeBoxes[a2,TraditionalForm](*,"Contradiction"*)
	]

getProof["specialcase"|{"specialcase",m_String}, l_List, out_] := (geomPrint[hggetProof[{m}, l, out]];
	(*Quiet@*)Column[Join[{"by algebra on "<>If[TrueQ[Quiet@StringQ[m]],m,"",""]<>":"}, myMakeBoxes[#,TraditionalForm]&/@(
						(*First/@*)If[MatchQ[l[[1]],"Angle"->_List],
										Join@@(Last/@DeleteCases[l,_String -> {}]),
										l[[All,1]]
									]	
								)(*[[;;Min[5,Length[l]]]]*)]])
getProof["specialcase"|{"specialcase",m_String}, rest___] := Column[{"Special case: "<>If[TrueQ[Quiet@StringQ[m]],m,"",""],myMakeBoxes[rest,TraditionalForm]}]
(*getProof["specialcase"|{"specialcase",m_String}, reasons_, eqns_] := Row[{m, (*", solving for: ...",*) reasons[[;;Min[5,Length[reasons]]]],"..."}]*)


(* ::Subsection:: *)
(*TraditionalForm formatting for geometric primitives*)


GeometricPoint /: myMakeBoxes[GeometricPoint[a_String], TraditionalForm] := a
GeometricPoint /: myMakeBoxes[GeometricPoint[a_], TraditionalForm] := ToString[a]
ConstructedGeometricPoint /: myMakeBoxes[ConstructedGeometricPoint[a_], TraditionalForm] := Subscript["p",ToString[a]]
ConstructedGeometricPointinProof /: myMakeBoxes[ConstructedGeometricPointinProof[a_], TraditionalForm] := Subscript["p",ToString[a]]

ConstructedEuclideanDistance /: myMakeBoxes[ConstructedEuclideanDistance[a_], TraditionalForm] := Subscript["d",ToString[a]]

Angle /: myMakeBoxes[Angle[a_,b_,c_,___], TraditionalForm] := StringJoin@@Join[{"\[Angle]"(*"\[MeasuredAngle]<"*)},myMakeBoxes[#,TraditionalForm]&/@{a,b,c}]
Angle /: myMakeBoxes[Angle[a_,b_,c_], TraditionalForm] := StringJoin@@Join[{"\[Angle]"},myMakeBoxes[#,TraditionalForm]&/@{a,b,c}]
(*Angle /: myMakeBoxes[Angle[a_,b_,c_,n_,___], TraditionalForm] := StringJoin@@Join[{"\[Angle]"},myMakeBoxes[#,TraditionalForm]&/@{a,b,c},{" = ",ToString[n, FormatType->StandardForm]," degrees"}]*)

LineThrough /: myMakeBoxes[l:LineThrough[{a__}], TraditionalForm] := Grid[{{#}},Dividers->{False,{1}}]&[Row[myMakeBoxes[#,TraditionalForm]&/@{a}]]
InfiniteLineThrough /: myMakeBoxes[l:InfiniteLineThrough[{a__}], TraditionalForm] := Grid[{{#}},Dividers->{False,{1}}]&[Row[myMakeBoxes[#,TraditionalForm]&/@{a}]](*OverscriptBox[TemplateBox[myMakeBoxes[#,TraditionalForm]&/@{a},"RowDefault"],"_"]*)(*OverBar[RowBox[#]]&/@(List@@List@@@l(*(List@@ll)[[All,1]]*))*)
Parallel /: myMakeBoxes[l:Parallel[(LineThrough|InfiniteLineThrough)[{__}]..], TraditionalForm] := (*ToString@*)
	Row[Join[myMakeBoxes[#,TraditionalForm]&/@(List@@l)(*Map[ToString,List@@List@@@l,{2}]*),If[Length[l]==1,{(*"are points on a line"*)"is a line"},{(*" are parallel lines"*)}]], If[Length[l]==1," ",(*","*)(*" \[DoubleVerticalBar] "*)" || "]] (*should be line1 ||  line2*)

CircleThrough /: myMakeBoxes[CircleThrough[p:{___},c_,r_], TraditionalForm] := 
			Row@TemplateApply[StringTemplate["circle with center `1` of radius `2` with points `3`", CombinerFunction -> Identity, InsertionFunction-> TraditionalForm],
			{
				myMakeBoxes[c,TraditionalForm],
				myMakeBoxes[r,TraditionalForm],
				myMakeBoxes[#,TraditionalForm]&/@p
			}](*StringJoin["Circle with center ", ToString[c], " of radius ",ToString[r, FormatType->StandardForm]," with points ",ToString[p]]*)

CircleArcLength /: myMakeBoxes[CircleArcLength[c_,r_,{a_,b_}], TraditionalForm] := 
			StringTemplate["arc of the circle with center `1` of radius `2` from `3` to `4`"(*," with points..."*)][
				myMakeBoxes[c,TraditionalForm],
				ToString[r, FormatType->StandardForm],
				myMakeBoxes[a,TraditionalForm],
				myMakeBoxes[b,TraditionalForm]
			]
CircleArcLength /: myMakeBoxes[CircleArcLength[c_,(*r_,*){a_,b_},ang_], TraditionalForm] := 
			StringTemplate["arc of the circle with center `1` from `3` to `4` has length `5`"][
				myMakeBoxes[c,TraditionalForm],
				(*ToString[r, FormatType->StandardForm]*)999,
				myMakeBoxes[a,TraditionalForm],
				myMakeBoxes[b,TraditionalForm]
			]

(*(Unprotect[EuclideanDistance];
EuclideanDistance /: myMakeBoxes[EuclideanDistance[x_GeometricPoint,y_GeometricPoint,d_], TraditionalForm] := StringJoin["distance(",ToString[x[[1]]],", ",ToString[y[[1]]],") = ",ToString[d, FormatType->TraditionalForm]];
EuclideanDistance /: *)myMakeBoxes[EuclideanDistance[x_GeometricPoint,y_GeometricPoint], TraditionalForm] := StringJoin["distance(",ToString[x[[1]]],", ",ToString[y[[1]]],")"];
(*Protect[EuclideanDistance]);*)

(*(Unprotect[Triangle];*)
(*Triangle /: *)myMakeBoxes[Triangle[{y_,z_,x_}], TraditionalForm] := StringTemplate["\[CapitalDelta]`1``2``3`"][Sequence@@(myMakeBoxes[#,TraditionalForm]&/@{y,z,x})](*StringJoin@@Join[{"\[CapitalDelta]"},myMakeBoxes[#,TraditionalForm]&/@{y,z,x}]*)
(*Protect[Triangle]);*)

GeometricArea /: myMakeBoxes[GeometricArea[{x__}], TraditionalForm] := StringJoin[{"area(",If[Length[{x}]==3,"\[CapitalDelta]",""],ToString/@First/@{x},")"}](*StringJoin[{{"\[CapitalDelta]"},ToString/@First/@{x}}]*)
GeometricArea /: myMakeBoxes[GeometricArea[Triangle[{x__}]], TraditionalForm] := StringJoin[{"area(\[CapitalDelta]",ToString/@First/@{x},")"}]
(*GeometricArea /: myMakeBoxes[GeometricArea[{x__}]\[Equal]a_, TraditionalForm] := StringJoin[{"area(",ToString/@First/@{x},")=",ToString[a]}]*)

RegionCenter /: myMakeBoxes[RegionCenter[t_, s_String], TraditionalForm] :=
	StringTemplate["(the `2` of `1`)"][myMakeBoxes[t,TraditionalForm], s]
	
Similar /: myMakeBoxes[Similar[a_,b_], TraditionalForm] := (*StringTemplate["`1` \[TildeFullEqual] `2`"][myMakeBoxes[a,TraditionalForm], myMakeBoxes[b,TraditionalForm]]*)
	Row@TemplateApply[StringTemplate["`1` \[TildeFullEqual] `2`", CombinerFunction -> Identity, InsertionFunction-> TraditionalForm],
		{myMakeBoxes[a,TraditionalForm],myMakeBoxes[b,TraditionalForm]}
	]
Tangent /: myMakeBoxes[Tangent[a_,b_], TraditionalForm] := (*Row[{"`1` is tangent to `2`"]*)
	Row@TemplateApply[StringTemplate["`1` is tangent to `2`", CombinerFunction -> Identity, InsertionFunction-> TraditionalForm],
		{myMakeBoxes[a,TraditionalForm],myMakeBoxes[b,TraditionalForm]}
	]


(* ::Input:: *)
(*(*a1=Angle[u,y,t,r];*)
(*myMakeBoxes[(*Angle[u,p,o]*)(*a1[[1;;3]]*)#,TraditionalForm]&[a1[[1;;3]]](*//TraditionalForm*)*)*)


(* ::Section:: *)
(*Theorems*)


(*
pattern matching is not great. speed up could come from customizing the search 
(esp. if we know the goal)
also genetic, ML algs on choice of section of theorems to try, based on current knowns
(tried in diff branch)

ways to restrict the number of knowns: make each Angle repr. the pair of angles for all sets of parallel lines.

note that, with a complete set of lines between any two points, only triangles are made.
 and only triangles of parallel classes matter?
\[Rule] add 'names' to parallel classes?

applyTheorem["name", specific premises, specific conclusion] gets called
*)

(*
Parallels are assumed to be listed all going in a consistent direction w.r.t. each others list of points

angles consistently follow a left- or right-hand rule, but this package is agnostic:
the same theorems would apply to a left- and right-handed diagram, and nothing here can tell the difference.

*)

anglethms = {
(*other angles of triangle given one*)
(*{___,
a1:Angle[x_,z_,y_,t___]==a_,
___} 
:>(applyTheorem["tri1",{a1},{Angle[y,x,z,t]==180-a-StringJoin[ToString/@First/@{z,y,x}],Angle[z,y,x,t]==180-a-StringJoin[ToString/@First/@{y,x,z}]}]),
*)
(*3rd angle of triangle given other 2*)
{q1___,
a2:Angle[x1_,z1_,y1_,t___]==b_,
q2___,
a1:Angle[x2_,z2_,y2_,t___]==a_,
q3___} /;  ((*Print["tri1"];*)Sort[{x1,z1,y1}]===Sort[{x2,z2,y2}] && x1=!=x2 && Length[Cases[{q1,q2,q3},#,3]&[If[x2===z1, Angle[y1,x1,z1], Angle[z1,y1,x1]]]]<2)
:>(applyTheorem["tri1",{a1,a2},If[x2===z1, Angle[y1,x1,z1,t]==180-a-b, Angle[z1,y1,x1,t]==180-a-b]]),

(*left\[Rule]right verson of angles: needed? no, elim'd in favor of agnosticism about orientation*)


(*angles by another name*)
{___,
Parallel[___,
l:InfiniteLineThrough[{___,x_,___,w_,___,c_,___}]|InfiniteLineThrough[{___,w_,___,x_,___,c_,___}]|InfiniteLineThrough[{___,c_,___,w_,___,x_,___}]|InfiniteLineThrough[{___,c_,___,x_,___,w_,___}],___],
___,
nn:Angle[x_,c_,z_,t___]==a_,
___} /; w=!=z
:>(applyTheorem["aban1", {l,nn}, Angle[w,c,z,t]==a]),

{___,
Parallel[___,
l:InfiniteLineThrough[{___,x_,___,w_,___,c_,___}]|InfiniteLineThrough[{___,w_,___,x_,___,c_,___}]|InfiniteLineThrough[{___,c_,___,w_,___,x_,___}]|InfiniteLineThrough[{___,c_,___,x_,___,w_,___}],___],
___,
nn:Angle[z_,c_,x_,t___]==a_,
___} /; w=!=z
:>((*uuu=9;*)(*Print["aban2",{l,nn}];*)applyTheorem["aban2", {l,nn}, Angle[z,c,w,t]==a]),


(*opposite angles (rem. right hand rule!) 
  none - supplementary is suff.*)


(*supplementary angles - comsolidate\[Rule]faster?*)
{___,
s1:Parallel[___,InfiniteLineThrough[{___,y_,___,c_,___,x_,___}]|InfiniteLineThrough[{___,x_,___,c_,___,y_,___}],___],
___,
s2:Parallel[___,InfiniteLineThrough[{___,z_,___,c_,___,w_,___}]|InfiniteLineThrough[{___,w_,___,c_,___,z_,___}],___],
___,
s3:Angle[y_,c_,z_,t___]==a_,
___} /; w=!=y
:>(applyTheorem["Supp1", {s1,s2,s3}, Angle[w,c,y, t]==180-a]),

{___,
s2:Parallel[___,InfiniteLineThrough[{___,z_,___,c_,___,w_,___}]|InfiniteLineThrough[{___,w_,___,c_,___,z_,___}],___],
___,
s1:Parallel[___,InfiniteLineThrough[{___,y_,___,c_,___,x_,___}]|InfiniteLineThrough[{___,x_,___,c_,___,y_,___}],___],
___,
s3:Angle[y_,c_,z_,t___]==a_,
___} /; w=!=y
:>(applyTheorem["Supp2", {s1,s2,s3}, Angle[w,c,y, t]==180-a]),

{___,
s1:Parallel[___,InfiniteLineThrough[{___,y_,___,c_,___,x_,___}]|InfiniteLineThrough[{___,x_,___,c_,___,y_,___}],___],(*not nec.? *)
___,
s2:Parallel[___,InfiniteLineThrough[{___,z_,___,c_,___,w_,___}]|InfiniteLineThrough[{___,w_,___,c_,___,z_,___}],___],
___,
s3:Angle[z_,c_,y_,t___]==a_,
___} /; w=!=y
:>(applyTheorem["Supp3", {s1,s2,s3}, Angle[y,c,w, t]==180-a]),

{___,
s2:Parallel[___,InfiniteLineThrough[{___,z_,___,c_,___,w_,___}]|InfiniteLineThrough[{___,w_,___,c_,___,z_,___}],___],
___,
s1:Parallel[___,InfiniteLineThrough[{___,y_,___,c_,___,x_,___}]|InfiniteLineThrough[{___,x_,___,c_,___,y_,___}],___],
___,
s3:Angle[z_,c_,y_,t_]==a_,
___} /; w=!=y
:>(applyTheorem["Supp4", {s1,s2,s3}, Angle[y,c,w, t]==180-a]),


(* corresponding angles 
rem. only diff between two ruledelayed's is order of InfiniteLineThrough[]s *)
{___,
gp:Parallel[___,
l2:InfiniteLineThrough[{___,z_,___,w_,___}]|InfiniteLineThrough[{___,w_,___,z_,___}],
___,
l1:InfiniteLineThrough[{___,x_,___,y_,___}]|InfiniteLineThrough[{___,y_,___,x_,___}],
___],
___,
ang:(Angle[w_|z_,y_,x_,t___]|Angle[x_,y_,w_|z_,t___])==a_,
___}
:>
With[{cen = If[FreeQ[ang[[1]],w],z,w], wz = If[FreeQ[ang[[1]],w],w,z]}, (*If[MatchQ[{l1,l2,cen},{InfiniteLineThrough[{___,x,___,y,___}],InfiniteLineThrough[{___,z,___,w,___}],z}|
							{InfiniteLineThrough[{___,y,___,x,___}],InfiniteLineThrough[{___,w,___,z,___}],z}|
							{InfiniteLineThrough[{___,y,___,x,___}],InfiniteLineThrough[{___,z,___,w,___}],w}|
							{InfiniteLineThrough[{___,x,___,y,___}],InfiniteLineThrough[{___,w,___,z,___}],w}] && MatchQ[ang[[1]],Angle[GeometricPoint@"w",GeometricPoint@"y",GeometricPoint@"x"]],
							Print["POP2",ang,{cen,wz}]];*)
	If[MatchQ[{l1,l2,cen},{InfiniteLineThrough[{___,x,___,y,___}],InfiniteLineThrough[{___,z,___,w,___}],z}|
							{InfiniteLineThrough[{___,y,___,x,___}],InfiniteLineThrough[{___,w,___,z,___}],z}|
							{InfiniteLineThrough[{___,y,___,x,___}],InfiniteLineThrough[{___,z,___,w,___}],w}|
							{InfiniteLineThrough[{___,x,___,y,___}],InfiniteLineThrough[{___,w,___,z,___}],w}], (*nec. if Parallel assumed to follow consistent order*)
		applyTheorem["ca1", {(*l1,l2,*)gp,ang}, If[ang[[1,1]]===x,
			geomPrint[{x,y,z,w},Angle[wz,cen,y,t]==a,"??-??"];Angle[wz,cen,y,t]==a,
			geomPrint[{x,y,z,w},Angle[y,cen,wz,t]==a,"??---??"];Angle[y,cen,wz,t]==a],
			"DisplayProofData"->{l1,l2,ang}
		],
		applyTheorem["ca2", {(*l1,l2*)gp,ang}, If[ang[[1,1]]===x,Angle[y,cen,wz,t]==180-a,Angle[wz,cen,y,t]==180-a],"DisplayProofData"->{l1,l2,ang}]
	]
],
(*"Proof"\[Rule]Angle["gp10",w,y,113]\[Rule]heldgetProof["ca2",{InfiniteLineThrough["gp11",x,y,"gp12"],InfiniteLineThrough["gp9",z,w,"gp10"],Angle[w,y,x,67]},Angle["gp10",w,y,113]]*)
{___,
gp:Parallel[___,
l1:InfiniteLineThrough[{___,x_,___,y_,___}]|InfiniteLineThrough[{___,y_,___,x_,___}],
___,
l2:InfiniteLineThrough[{___,z_,___,w_,___}]|InfiniteLineThrough[{___,w_,___,z_,___}],
___],
___,
ang:(Angle[w_|z_,y_,x_,t___]|Angle[x_,y_,w_|z_,t___])==a_,
___}
:>
With[{cen = If[FreeQ[ang[[1]],w],z,w], wz = If[FreeQ[ang[[1]],w],w,z]}, (*If[MatchQ[{l1,l2,cen},{InfiniteLineThrough[{___,x,___,y,___}],InfiniteLineThrough[{___,z,___,w,___}],z}|
							{InfiniteLineThrough[{___,y,___,x,___}],InfiniteLineThrough[{___,w,___,z,___}],z}|
							{InfiniteLineThrough[{___,y,___,x,___}],InfiniteLineThrough[{___,z,___,w,___}],w}|
							{InfiniteLineThrough[{___,x,___,y,___}],InfiniteLineThrough[{___,w,___,z,___}],w}]&& MatchQ[ang[[1]],Angle[GeometricPoint@"w",GeometricPoint@"y",GeometricPoint@"x"]],
							Print["POP",{cen,wz}]];*)
	If[MatchQ[{l1,l2,cen},{InfiniteLineThrough[{___,x,___,y,___}],InfiniteLineThrough[{___,z,___,w,___}],z}|
							{InfiniteLineThrough[{___,y,___,x,___}],InfiniteLineThrough[{___,w,___,z,___}],z}|
							{InfiniteLineThrough[{___,y,___,x,___}],InfiniteLineThrough[{___,z,___,w,___}],w}|
							{InfiniteLineThrough[{___,x,___,y,___}],InfiniteLineThrough[{___,w,___,z,___}],w}],
		applyTheorem["ca1", {(*l1,l2,*)gp,ang}, 
			If[ang[[1,1]]===x,
				geomPrint[{x,y,z,w},Angle[wz,cen,y,t]==a,"????"];Angle[wz,cen,y,t]==a, 
				geomPrint[{x,y,z,w},Angle[y,cen,wz,t]==a,"??--??"];Angle[y,cen,wz,t]==a],
				"DisplayProofData"->{l1,l2,ang}
		],
		applyTheorem["ca2", {(*l1,l2*)gp,ang}, If[ang[[1,1]]===x,Angle[y,cen,wz,t]==180-a,Angle[wz,cen,y,t]==180-a],"DisplayProofData"->{l1,l2,ang}]
	]
],

(*need "ca3/4"?*)


(*angle addition/subtraction*)
{
	___,
	Angle[y1_,x_,z1_,t___]==a_?(#!=0&),
	___,
	Angle[y2_,x_,z2_,t___]==b_(*?(#\[NotEqual]0&)*),
	___
} /; ((y1===y2 && z1=!=z2)  || (z1===z2 && y1=!=y2)) && BooleanQ[b>a]
:>((*Print["ppp------p0o",Angle[y1,x,z1],Angle[y2,x,z2]];*) applyTheorem["add1", 
	{Angle[y1,x,z1,t]==a, Angle[y2,x,z2,t]==b}, 
	If[y1===y2,
		If[b>a,
			Angle[z1,x,z2,t]==Abs[b-a],
			Angle[z2,x,z1,t]==Abs[b-a]
		],
		If[b>a,
			Angle[y2, x, y1,t]==Abs[b-a],
			Angle[y1, x, y2,t]==Abs[b-a]
		]
	]
]),

{
	___,
	Angle[y1_,x_,z1_,t___]==a_?(#!=0&),
	___,
	Angle[y2_,x_,z2_,t___]==b_(*?(#\[NotEqual]0&)*),
	___
} /; ((y1===z2 && z1=!=y2)  || (z1===y2 && y1=!=z2))
:>((*Print["add1 --real1y",Angle[y1,x,z1],Angle[y2,x,z2]];*) applyTheorem["add1", 
	{Angle[y1,x,z1,t]==a, Angle[y2,x,z2,t]==b}, 
	If[z1===y2,
		Angle[y1,x,z2,t]==b+a,
		Angle[y2,x,z1,t]==b+a
	]
]),

(*the base angles of an isosceles triangle are equal. - used in Thales thm, e.g.*)
{
	q1___,
	n1:EuclideanDistance[p1_,p2_]==a_,
	q2___,
	n2:EuclideanDistance[p3_,p4_]==a_,
	q3___
} /; Length[DeleteDuplicates[{p1,p2,p3,p4}]]===3
:>((*Print["fromisoceleslen",n1,n2];*) Module[{common, x,y,orderex},
	common = First[Intersection[{p1,p2},{p3,p4}]];
	x = First[Complement[{p1,p2},{common}]]; 
	y = First[Complement[{p3,p4},{common}]];
	orderex = Cases[{q1,q2,q3},Angle[x,y, common]|Angle[common,x,y]|Angle[y,common,x],2,1];
	applyTheorem["fromisoceleslen", 
		{n1,n2}, 
		If[orderex==={},
			Angle[y,x, common] == Angle[common, y,x],
			Angle[common,x,y] == Angle[x,y,common]
		]
	]
])


};


lengththms = {

(*one more for L and R?*)

(*parallel is a equiv. rel. (agglomerate p. lines rule, should be here, not in pre-proc)
also if we prove an angle of 180 we could collapse Parallel classes into smaller set *)



(*///////////////////////          LENGTHS         ///////////////////////////*)

(*basic length addition/subtraction on a line*)
(*REM: LENGTHS SHOULD ALWAYS FOLLOW ORDERS IN LINES, but not nec order OF lens/lines (yet)*)
{___,
gp:(Parallel|Tangent)[___,l1:InfiniteLineThrough[{___,p1_,___,p2_,___,p3_,___}]|InfiniteLineThrough[{___,p3_,___,p2_,___,p1_,___}],___],
___,
n1:EuclideanDistance[p1_,p2_]==a_|EuclideanDistance[p2_,p1_]==a_,
___,
n2:EuclideanDistance[p2_,p3_]==b_|EuclideanDistance[p3_,p2_]==b_,
___} /; (VectorQ[{a,b}, NumericQ[#] || (FreeQ[#,Max|Min,Heads->True] && Depth[#]<3(*arbitrary safety, maybe delete*)) &])
:>(applyTheorem["len1", {(*{p1,p2,p3}*)gp, n1, n2}, (*Print["len1", {(*{p1,p2,p3}*)gp, n1, n2}];*)
		If[(*MatchQ[l1,InfiniteLineThrough[___,p1,___,p2,___,p3,___]]*)Sort[{p1,p3}]==={p1,p3},
												EuclideanDistance@@vSort[{p1, p3}] == Rationalize[a+b](*signed length?*),
												EuclideanDistance@@vSort[{p3, p1}] == Rationalize[a+b](*signed length?*)],
												"DisplayProofData"->{{p1,p2,p3}, n1, n2}
											]
	),

{___,
gp:(Parallel|Tangent)[___,l1:InfiniteLineThrough[{___,p1_,___,p2_,___,p3_,___}]|InfiniteLineThrough[{___,p3_,___,p2_,___,p1_,___}],___],
___,
n1:EuclideanDistance[p1_,p3_]==a_,
___,
n2:EuclideanDistance[p2_,p1_]==b_|EuclideanDistance[p2_,p3_]==b_|EuclideanDistance[p3_,p2_]==b_|EuclideanDistance[p1_,p2_]==b_,
___} 
:>(applyTheorem["len2", {(*{p1,p2,p3}*)gp, n1, n2},(*Print["Len2a",{(*{p1,p2,p3}*)gp, n1, n2},{Rationalize[a-b]}];*) 
	(*If[MatchQ[l1,InfiniteLineThrough[___,p1,___,p2,___,p3,___]],
		If[MatchQ[n2[[1]],EuclideanDistance[p1,p2]|EuclideanDistance[p2,p1]],EuclideanDistance@@vSort[{p2,p3}]==Rationalize[a-b],EuclideanDistance@@vSort[{p1,p2}]==Rationalize[a-b]],
		If[MatchQ[n2[[1]],EuclideanDistance[p1,p2]|EuclideanDistance[p2,p1]],EuclideanDistance@@vSort[{p3,p2}]==Rationalize[a-b],EuclideanDistance@@vSort[{p2,p1}]==Rationalize[a-b]]
	]*)If[MatchQ[n2[[1]],EuclideanDistance@@vSort[{p1,p2}]],EuclideanDistance@@vSort[{p2,p3}]==Rationalize[a-b],EuclideanDistance@@vSort[{p1,p2}]==Rationalize[a-b]],
	 "DisplayProofData"->{{p1,p2,p3}, n1, n2}]),
(*only diff with above thm is order in which EuclideanDistance's appear*)
{___,
gp:(Parallel|Tangent)[___,l1:InfiniteLineThrough[{___,p1_,___,p2_,___,p3_,___}]|InfiniteLineThrough[{___,p3_,___,p2_,___,p1_,___}],___],
___,
n2:EuclideanDistance[p2_,p1_]==b_|EuclideanDistance[p2_,p3_]==b_|EuclideanDistance[p3_,p2_]==b_|EuclideanDistance[p1_,p2_]==b_,
___,
n1:EuclideanDistance[p1_,p3_]==a_,
___}
:>(applyTheorem["len2", {(*{p1,p2,p3}*)gp, n1, n2}, (*Print["Len2b",{(*{p1,p2,p3}*)gp, n1, n2},{Rationalize[a-b]}];*)
	If[MatchQ[n2[[1]],EuclideanDistance@@vSort[{p1,p2}]],
		EuclideanDistance@@vSort[{p3,p2}]==Rationalize[a-b],
		EuclideanDistance@@vSort[{p1,p2}]==Rationalize[a-b]
	](*MatchQ[l1,InfiniteLineThrough[___,p1,___,p2,___,p3,___]],
		If[MatchQ[n2[[1]],EuclideanDistance[p1,p2]],EuclideanDistance[p2,p3]==Rationalize[a-b],EuclideanDistance[p1,p2]==Rationalize[a-b]],
		If[MatchQ[n2[[1]],EuclideanDistance[p2,p1]],EuclideanDistance[p3,p2]==Rationalize[a-b],EuclideanDistance[p2,p1]==Rationalize[a-b]]*)
	,"DisplayProofData"->{{p1,p2,p3}, n1, n2}]),

(*probably need:

 {___,
Parallel[___,l1:InfiniteLineThrough[{___,p2_,___,p1_,___,p3_,___}]|InfiniteLineThrough[{___,p3_,___,p1_,___,p2_,___}]|InfiniteLineThrough[{___,p2_,___,p3_,___,p1_,___}]|InfiniteLineThrough[{___,p2_,___,p3_,___,p1_,___}],___],
___,
n1:EuclideanDistance[p2_,p1_]\[Equal]a,
___,
n2:EuclideanDistance[p2_,p3_,b_]|EuclideanDistance[p3_,p2_,b_],
___}
:>(applyTheorem["len2", {{p1,p2,p3}, n1, n2}, EuclideanDistance[p1, p2, a-b]]),
 *)
 
 (* 'corresponding' parallel segments (ie those whose endpoints form another pair of parallel lines) *)
{___,
gp1:Parallel[___,l1:InfiniteLineThrough[{___,p1_,___,p2_,___}],___,l2:InfiniteLineThrough[{___,p3_,___,p4_,___}],___],
___,
gp2:Parallel[___,l3:InfiniteLineThrough[{___,p1_,___,p3_,___}]|InfiniteLineThrough[{___,p3_,___,p1_,___}],___,l4:InfiniteLineThrough[{___,p2_,___,p4_,___}]|InfiniteLineThrough[{___,p4_,___,p2_,___}],___],
___,
len1:(EuclideanDistance[p1_,p2_]|EuclideanDistance[p3_,p4_])==a_?NumericQ,
___}|{___,
gp2:Parallel[___,l3:InfiniteLineThrough[{___,p1_,___,p3_,___}]|InfiniteLineThrough[{___,p3_,___,p1_,___}],___,l4:InfiniteLineThrough[{___,p2_,___,p4_,___}]|InfiniteLineThrough[{___,p4_,___,p2_,___}],___],
___,
gp1:Parallel[___,l1:InfiniteLineThrough[{___,p1_,___,p2_,___}],___,l2:InfiniteLineThrough[{___,p3_,___,p4_,___}],___],
___,
len1:(EuclideanDistance[p1_,p2_]|EuclideanDistance[p3_,p4_])==a_?NumericQ,
___}
:>(applyTheorem["parallelsegmentLen", {gp1,gp2,len1}, geomPrint["/////",{gp1,gp2,len1},"/////",If[MatchQ[len1,EuclideanDistance@@vSort[{p1,p2}]==a],EuclideanDistance@@vSort[{p3,p4}]==a,EuclideanDistance@@vSort[{p1,p2}]==a]];
	If[MatchQ[len1,EuclideanDistance@@vSort[{p1,p2}]==a],EuclideanDistance@@vSort[{p3,p4}]==a,EuclideanDistance@@vSort[{p1,p2}]==a]
	])

 (*need a corressponding angs \[Rule] parallel rule??? or can we just do this *) 

};


lenangthms = {
(* segments both between the same pair of parallel lines, 
with both lengths known. 
a is where the angle is *)
{___,
Parallel[___,l1:InfiniteLineThrough[{___,a_,___,b_,___}]|InfiniteLineThrough[{___,b_,___,a_,___}],___,l2:InfiniteLineThrough[{___,c_,___,d_,___}]|InfiniteLineThrough[{___,d_,___,c_,___}],___]|
Parallel[___,l2:InfiniteLineThrough[{___,c_,___,d_,___}]|InfiniteLineThrough[{___,d_,___,c_,___}],___,l1:InfiniteLineThrough[{___,a_,___,b_,___}]|InfiniteLineThrough[{___,b_,___,a_,___}],___],
___,
gl1:EuclideanDistance[a_,c_]==len1_|EuclideanDistance[c_,a_]==len1_,
___,
gl2:EuclideanDistance[b_,d_]==len2_|EuclideanDistance[d_,b_]==len2_,
___,
ang:(Angle[c_,a_,x_,___]|Angle[x_,a_,c_,___]|Angle[c_,a_,x_,___]|Angle[x_,a_,c_,___]|
	Angle[b_,d_,y_,___]|Angle[b_,d_,y_,___]|Angle[d_,b_,y_,___]|Angle[y_,b_,d_,___])==_,
___} /;   MemberQ[If[!True,l1,l2],If[MemberQ[ang,d],y,x]] 
:> With[{newang = (*Round[180 ArcSin[len2/len1]/Pi]*)simpFakeInts[180 N[ArcSin[Sin[ang[[2]] Degree] If[MemberQ[ang,d],len1/len2,len2/len1]]]/Pi]},
		geomPrint[N@ArcSin[Sin[ang[[2]] Degree] If[MemberQ[ang[[1]],d],len1/len2,len2/len1]],HoldForm[ArcSin[Sin[ang[[2]] Degree] If[MemberQ[ang[[1]],d],len1/len2,len2/len1]]],"[][]",ang[[2]],Sin[ang[[2]]],If[MemberQ[ang[[1]],d],len1/len2,len2/len1],MemberQ[ang[[1]],d]];
		applyTheorem["SegsTweenParall1",
			{gl1,gl2,ang},
			If[!True(* NEEDS FIXING!, MATTERS IF SAME SLANT DIRECTION OR OPPOSITE () *),Angle[b,d,c]==newang,Angle[c,d,b]==newang]
		]
	],

(*segments both between the same pair of parallel lines, 
with both angles known*)
{(*___,
(lnew:InfiniteLineThrough[___,b_,___,d_,___]|InfiniteLineThrough[___,d_,___,b_,___])|Parallel[___,lnew:InfiniteLineThrough[{___,b_,___,d_,___}]|InfiniteLineThrough[{___,d_,___,b_,___}],___],
*)___,
Parallel[___,l1:InfiniteLineThrough[{___,a_,___,b_,___}]|InfiniteLineThrough[{___,b_,___,a_,___}],___,l2:InfiniteLineThrough[{___,c_,___,d_,___}]|InfiniteLineThrough[{___,d_,___,c_,___}],___],
___,
gl:(EuclideanDistance[a_,c_]|EuclideanDistance[c_,a_])==len_,
___,
ang1:(Angle[b_,d_,y_,___]|Angle[b_,d_,y_,___]|Angle[d_,b_,y_,___]|Angle[y_,b_,d_,___])==v1_,
___,
ang2:(Angle[x_,a_,c_,___]|Angle[c_,a_,x_,___]|Angle[x_,c_,a_,___]|Angle[a_,c_,x_,___])==v2_,
___}|{___,
Parallel[___,l1:InfiniteLineThrough[{___,a_,___,b_,___}]|InfiniteLineThrough[{___,b_,___,a_,___}],___,l2:InfiniteLineThrough[{___,c_,___,d_,___}]|InfiniteLineThrough[{___,d_,___,c_,___}],___],
(*___,
(lnew:InfiniteLineThrough[{___,b_,___,d_,___}]|InfiniteLineThrough[{___,d_,___,b_,___}])|Parallel[___,lnew:InfiniteLineThrough[{___,b_,___,d_,___}]|InfiniteLineThrough[{___,d_,___,b_,___}],___],
*)___,
gl:(EuclideanDistance[a_,c_]|EuclideanDistance[c_,a_])==len_,
___,
ang1:(Angle[b_,d_,y_,___]|Angle[b_,d_,y_,___]|Angle[d_,b_,y_,___]|Angle[y_,b_,d_,___])==v1_,
___,
ang2:(Angle[x_,a_,c_,___]|Angle[c_,a_,x_,___]|Angle[x_,c_,a_,___]|Angle[a_,c_,x_,___])==v2_,
___} /; (NumericQ[len] || NumericQ[v1] && NumericQ[v2])(*MatchQ[lines},*)
			(*Parallel[___,l1:InfiniteLineThrough[___,a_,___,b_,___]|InfiniteLineThrough[___,b_,___,a_,___],___,l2:InfiniteLineThrough[___,c_,___,d_,___]|InfiniteLineThrough[___,d_,___,c_,___],___]|
			Parallel[___,l2:InfiniteLineThrough[___,c_,___,d_,___]|InfiniteLineThrough[___,d_,___,c_,___],___,l1:InfiniteLineThrough[___,a_,___,b_,___]|InfiniteLineThrough[___,b_,___,a_,___],___]
		] 
		*) && MemberQ[If[MatchQ[ang2,(Angle[x,a,c,___]|Angle[c,a,x,___])==_],l1,l2],x] 
		 && MemberQ[If[MatchQ[ang1,(Angle[b,d,y,___]|Angle[b,d,y,___])==_],l2,l1],y]
			(*&& !(v1\[Equal]v2\[Equal]90)*) (*should be parallel?*)
:> With[{newlen = N[len Sin[ang2[[2]] Degree]/Sin[ang1[[2]] Degree]]},
		applyTheorem["SegsTweenParall2",
			{gl,ang1,ang2},
			(*If[MatchQ[lnew, InfiniteLineThrough[___,b,___,d,___]],EuclideanDistance[b,d],EuclideanDistance[d,b]]*)
			EuclideanDistance@@vSort[{b,d}]==newlen
		]
	],
(*reverse angs! (or lines) in abov rule*)
(*{___,
Parallel[___,l1:InfiniteLineThrough[{___,a_,___,b_,___}]|InfiniteLineThrough[{___,b_,___,a_,___}],___,l2:InfiniteLineThrough[{___,c_,___,d_,___}]|InfiniteLineThrough[{___,d_,___,c_,___}],___]|
Parallel[___,l2:InfiniteLineThrough[{___,c_,___,d_,___}]|InfiniteLineThrough[{___,d_,___,c_,___}],___,l1:InfiniteLineThrough[{___,a_,___,b_,___}]|InfiniteLineThrough[{___,b_,___,a_,___}],___],
___,
gl:EuclideanDistance[a_,c_]==len_|EuclideanDistance[c_,a_]==len_,
___,
ang2:(Angle[x_,a_,c_,___]|Angle[c_,a_,x_,___]|Angle[x_,c_,a_,___]|Angle[a_,c_,x_,___])\[Equal]v1_,
___,
ang1:(Angle[b_,d_,y_,___]|Angle[b_,d_,y_,___]|Angle[d_,b_,y_,___]|Angle[y_,b_,d_,___])\[Equal]v2_,
___} /;  MemberQ[If[MatchQ[ang1[[1]],Angle[x,a,c,___]|Angle[c,a,x,___]],l1,l2],x] 
			&& MemberQ[If[MatchQ[ang2[[1]],Angle[b,d,y,___]|Angle[b,d,y,___]],l2,l1],y]
			(*&& !(v1\[Equal]v2\[Equal]90)*)
:> With[{newlen = len Sin[ang2[[2]] Degree]/Sin[ang1[[2]] Degree]},
		applyTheorem["SegsTweenParall2",
			{gl,ang1,ang2},
			EuclideanDistance[Sequence@@Sort[{b,d}]]==newlen
		]
	],
*)
(*pythagorean theorem -subsume with above? no, replace with general law of sines? AND CONVERSE OF PYTHAGORUS, ... - really case of above where b===d*)
{___,
Parallel[___,l1:InfiniteLineThrough[{___,p1_,___,p3_,___}]|InfiniteLineThrough[{___,p3_,___,p1_,___}],___], (*needed for ordering?*)
___,
n1:EuclideanDistance[p1_,p2_]==a_|EuclideanDistance[p2_,p1_]==a_,
___,
n2:EuclideanDistance[p2_,p3_]==b_|EuclideanDistance[p3_,p2_]==b_,
___,
ang:Angle[_,_,_,___]==_?(#==90&),
___} /; Sort[List@@ang[[1,1;;3]]]===Sort[{p1,p2,p3}] && (VectorQ[{a,b}, NumericQ[#] || (FreeQ[#,Max|Min,Heads->True] && Depth[#]<3(*arbitrary safety, maybe delete*)) &])
:>((*Print[(*Column@*){l1,n1,n2,ang,If[MatchQ[l1,InfiniteLineThrough[___,p1,___,p3,___]],
	If[ang[[1,2]]===p2, 
		applyTheorem["pythag-hypot", {ang,n1,n2}, EuclideanDistance[p1,p3, simpFakeInts@Sqrt[a^2 + b^2]]],
		applyTheorem["pythag-side", {ang,n1,n2}, EuclideanDistance[p1,p3, simpFakeInts@Sqrt[Max[a,b]^2 - Min[a,b]^2]]]
	],
	If[ang[[1,2]]===p2, 
		applyTheorem["pythag-hypot", {ang,n1,n2}, EuclideanDistance[p3,p1, simpFakeInts@Sqrt[a^2 + b^2]]],
		applyTheorem["pythag-side", {ang,n1,n2}, EuclideanDistance[p3,p1, simpFakeInts@Sqrt[Max[a,b]^2 - Min[a,b]^2]]]
	]
   ]}//tfc];*) If[MatchQ[l1,InfiniteLineThrough[{___,p1,___,p3,___}]],
	If[ang[[1,2]]===p2, 
		applyTheorem["pythag-hypot", {ang,n1,n2}, EuclideanDistance@@vSort[{p1,p3}]==simpFakeInts@Sqrt[a^2 + b^2]],
		applyTheorem["pythag-side", {ang,n1,n2}, EuclideanDistance@@vSort[{p1,p3}]==simpFakeInts@Sqrt[Max[a,b]^2 - Min[a,b]^2]]
	],
	If[ang[[1,2]]===p2, 
		applyTheorem["pythag-hypot", {ang,n1,n2}, EuclideanDistance@@vSort[{p1,p3}] == simpFakeInts@Sqrt[a^2 + b^2]],
		applyTheorem["pythag-side", {ang,n1,n2}, EuclideanDistance@@vSort[{p1,p3}] == simpFakeInts@Sqrt[Max[a,b]^2 - Min[a,b]^2]]
	]
   ]),

{___,
Parallel[___,lin:InfiniteLineThrough[{___,p1_,___,p3_,___}]|InfiniteLineThrough[{___,p3_,___,p1_,___}],___], (*needed for name of p3? ordering?*)
___,
n1:EuclideanDistance[p1_,p2_]==a_?NumericQ|EuclideanDistance[p2_,p1_]==a_?NumericQ,
___,
ang1:Angle[_,p1_,_,t___]==b_,
___,
ang:Angle[_,p3_,_,___]==90,
___} /; Sort[(*Print[{p1,p2,p3},Union[List@@ang1[[1;;3]],List@@ang[[1;;3]]]];*)Union[List@@ang1[[1,1;;3]],List@@ang[[1,1;;3]]]]===Sort[{p1,p2,p3}]
:> applyTheorem["trig-or-special-triangles",  (* the difference is only in how we write the reason (formatting) *)
	(*Print["DRR"];*){n1,ang,ang1}, 
	If[ang[[1,2]]===p3 (*hypoteneuse is given*),(*Print["hypoteneuse is given"];*)
		If[ang1[[1,2]]===p1,
			{(*EuclideanDistance[If[MatchQ[lin,InfiniteLineThrough[{___,p1,___,p3,___}]],Sequence@@{p1,p3},Sequence@@{p3,p1}]]*)EuclideanDistance@@vSort[{p1,p3}] == simpFakeInts[a N@Cos[b Degree]], EuclideanDistance@@vSort[{p2,p3}] == simpFakeInts[a N@Sin[b Degree]]},
			{(*EuclideanDistance[If[MatchQ[lin,InfiniteLineThrough[{___,p1,___,p3,___}]],Sequence@@{p1,p3},Sequence@@{p3,p1}]]*)EuclideanDistance@@vSort[{p1,p3}] == simpFakeInts[a N@Sin[b Degree]], EuclideanDistance@@vSort[{p2,p3}] == simpFakeInts[a N@Cos[b Degree]]}
		],
		If[ang1[[1,2]]===p1,
			{(*EuclideanDistance[If[MatchQ[lin,InfiniteLineThrough[{___,p1,___,p3,___}]],Sequence@@{p1,p3},Sequence@@{p3,p1}]]*)EuclideanDistance@@vSort[{p1,p3}] == simpFakeInts[a N@Tan[b Degree]], EuclideanDistance@@vSort[{p2,p3}] == simpFakeInts[a N@Sin[b Degree]]},
			{(*EuclideanDistance[If[MatchQ[lin,InfiniteLineThrough[{___,p1,___,p3,___}]],Sequence@@{p1,p3},Sequence@@{p3,p1}]]*)EuclideanDistance@@vSort[{p1,p3}] == simpFakeInts[a N@Cos[b Degree]], EuclideanDistance@@vSort[{p2,p3}] == simpFakeInts[a N@Tan[b Degree]]}
		]
	]
]};


congsimthms = {

(*y cant cong/simil. angles be a consequence of the pre-proc. 'dead-beginning thm' after we conclude similarity here!!!!*)

(*side-angle-side congruence(similarity next), sharing one side, p1-p2: 
could we make rule output a (faster to apply) set of rules (each angle pair and len pair is =)?*)
{___,
d1:EuclideanDistance[p1_,p3_]==a_|EuclideanDistance[p3_,p1_]==a_,
___,
d2:EuclideanDistance[p1_,p4_]==a_|EuclideanDistance[p4_,p1_]==a_,
___,
ang1:Angle[p3_,p1_,p2_,t___]==b_,
___,
ang2:Angle[p2_,p1_,p4_,t___]==b_,
___
} :> (applyTheorem["cong1", {d1,d2,ang1,ang2}, geomPrint["cong1",{d1,d2,ang1,ang2}];
		With[{newd=Symbol[StringJoin["dist",First/@{p2,p3}]],
				newang1=Symbol[StringJoin["m\[Angle]",First/@{p1,p2,p3}]] (* we want vars instead of Geometric`constructs *),
				newang2=Symbol[StringJoin["m\[Angle]",First/@{p2,p3,p1}]]},
			{Angle[p1,p2,p3]==(*newang1,*)Angle[p4,p2,p1](*==newang1*),
			Angle[p2,p3,p1]==(*newang2,*)Angle[p1,p4,p2](*==newang2*),
			(*don't need? or should we use EuclideanDistance[Sequence@@Sort[{p2,p3}]] as newd?:
			EuclideanDistance[Sequence@@Sort[{p2,p3}]]==newd, *)
			EuclideanDistance[Sequence@@vSort[{p2,p4}]]==EuclideanDistance[Sequence@@vSort[{p2,p3}]]}
		]
	]),

	(*{___,angs:(Angle[__]..),___}
	\[RuleDelayed] With[{cnts=CountsBy[{angs},#[[1;;3]]]},
		If[Values[Take[cnts,{2}]][[1]] < 3,
			(* < 2 complete triangles*)Return["Ignore"],
			
		]
	d]*)

(*can prove intersecting chords thm?? (https://proofwiki.org/wiki/Intersecting_Chord_Theorem)
should we add that thm anyway? probably, but it would be cool to be able to do both *)
{___,
a1:Angle[x_,y_,z_,t___]==origang1_,
___,
a2:Angle[_,_,_,___] == origang2_,
___,
a3:Angle[_,_,_,___]==origang3_,
___,
a4:Angle[_,_,_,___]==origang4_,
(*___,
a5:Angle[_,_,_,___]==(ang2_|ang1_|ang3_),  DON'T NEED 3RD ANGLES TO MATCH!
___,
a6:Angle[_,_,_,___]==(ang2_|ang1_|ang3_),*)
___}
:>(Module[{group1, group2, ang1, ang2, ang3, angs, sameOrientQ, sharedside1, sharedside2},
	angs =  DeleteDuplicates[{origang1,origang2,origang3,origang4}, Equal];
	If[Length[angs]=!=2 || Sort[DeleteDuplicates[Join[List@@a2[[1]],List@@a3[[1]],List@@a4[[1]]]]]===Sort[{x,y,z}]  || Length[DeleteDuplicates[First/@{a1,a2,a3,a4}]]<4,"Ignore",
	{ang1, ang2} = If[origang1==#[[1]],#,Reverse[#]]&[angs];
	(*ang3 = 180-ang1-ang2; : should be done with tri1, I think*)
	group1 = Select[{a2,a3,a4}, MatchQ[List@@#[[1,1;;3]],{z,x,y}|{y,z,x}]&];
	geomPrint["In similar1..",angs,tfc[{a1,a2,a3,a4}],tfc/@{group1,{z,x,y},a1}];
	If[Length[group1]=!=1,"Ignore"(*Return[{}(*$Failed*)]*),
	group2 = SortBy[Complement[{a2,a3,a4},group1],#[[-1]]&];
	If[!Quiet@(Sort[group2[[1,1,1;;3]]]===Sort[group2[[2,1,1;;3]]]), "Ignore",(*Print["lll",group2];*)
	group1 = SortBy[Join[{a1},group1],#[[-1]]&];
	sharedside1 = Replace[group1, {___, _[___,p_,r_,___]==_ ,___, _[___,p_,r_,___]==_,___}:>{p,r}];
	sharedside2 = Replace[group2, {___, _[___,p_,r_,___]==_ ,___, _[___,p_,r_,___]==_,___}:>{p,r}];
	(*Print[rReplace[group1, HoldPattern[{___, Angle[___,ps_,rs_,___]==_ ,___, Angle[___,ps_,rs_,___]==_,___}]:>{ps,rs}],"{sharedside1,sharedside2}",{sharedside1,sharedside2}, cCases[group1,Angle[Sequence@@sharedside1,__]==_],Cases[group2,Angle[Sequence@@sharedside2,__]==_]];*)
	sameOrientQ = TrueQ[Cases[group1,Angle[Sequence@@sharedside1,__]==_][[1,-1]] == Cases[group2,Angle[Sequence@@sharedside2,__]==_][[1,-1]]];
	geomPrint[";;2;",tfc/@{group1, group2}(*{{{Sort[group2[[All,-1]]],Sort[group1[[All,-1]]],Sort[(*First/@*){ang1,ang2}]}}}*)(*Ssort[group1[[All,-1]]], Sort[group1[[All,-1]]]*)];
	If[(*  diag9 errs???  !(Sort[group1[[1,1;;3]]]===Sort[group1[[2,1;;3]]]) || *)
		!(Sort[group2[[All,-1]]]===Sort[group1[[All,-1]]]===Sort[(*First/@*){ang1,ang2}]),"Ignore"(*Return[{}(*$Failed*)]*),
		
	geomPrint["{group1,group2}",tfc/@{group1,group2}];
	If[{List@@Sort[group1[[1,1,1;;3,1]]],List@@Sort[group2[[1,1,1;;3,1]]]}=!=Sort@{List@@Sort[group1[[1,1,1;;3,1]]],List@@Sort[group2[[1,1,1;;3,1]]]}, {group1,group2}={group2,group1}];
	geomPrint["{group1,group2}!!!",tfc/@{group1,group2}];
	(*need to fix names to be unique and Lengths to be in correct order (with lines) - DONE i think*)
	With[{newconst = Symbol[StringJoin["simConstant\[UnderBracket]\[CapitalDelta]",(*Sort@*){(*First/@{x,y,z}*)List@@Sort[group1[[1,1,1;;3,1]]],"\[UnderBracket]\[CapitalDelta]",List@@Sort[group2[[1,1,1;;3,1]]]}](*<>ToString[RandomInteger[999]] -cant use random (since we need to delete dup thms, and this const is in thms) but need id 2 triangles*)],
		 (* newd1 = Symbol["dist"<>group1[[1,1,1]]<>group1[[1,3,1]]], 
		  newd2 = Symbol["dist"<>group1[[2,1,1]]<>group1[[2,3,1]]], 
		  newd3 = Symbol["dist"<>group1[[3,1,1]]<>group1[[3,3,1]]],*)
		  grp1 = group1[[All,1]],
		  grp2 = group2[[All,1]]},
		applyTheorem["similar1",(*{{x,y,z}, List@@grp2[[1]]},*){group1,group2}, (*Print["new dist's: ",{grp1,grp2}(*,{newd1,newd2,newd3}*)];*)
			If[sameOrientQ(*reflected similarity??*),
			{
			
			EuclideanDistance@@vSort[{grp2[[1,1]],grp2[[1,3]]}]== newconst EuclideanDistance@@vSort[{grp1[[1,1]],grp1[[1,3]]}],
			EuclideanDistance@@vSort[{grp2[[1,2]],grp2[[1,3]]}]== newconst EuclideanDistance@@vSort[{grp1[[1,2]],grp1[[1,3]]}],
			EuclideanDistance@@vSort[{grp2[[1,1]],grp2[[1,2]]}]==newconst EuclideanDistance@@vSort[{grp1[[1,1]],grp1[[1,2]]}]
			}
			,
			{
			EuclideanDistance@@vSort[{grp2[[1,1]],grp2[[1,3]]}]== newconst EuclideanDistance@@vSort[{grp1[[1,1]],grp1[[1,3]]}],(*TODO: NEED to distinguish similarity v. flipped similarity*)
			EuclideanDistance@@vSort[{grp2[[1,2]],grp2[[1,3]]}]== newconst EuclideanDistance@@vSort[{grp1[[1,2]],grp1[[1,1]]}],
			EuclideanDistance@@vSort[{grp2[[1,1]],grp2[[1,2]]}]==newconst EuclideanDistance@@vSort[{grp1[[1,3]],grp1[[1,2]]}]
			}](*, angle 3: should be done with tri1, I think*),
			"DisplayProofData"->{{x,y,z}, List@@grp2[[1]],angs}
		]

	]
	]]]]
])	

(*need AAS (diags[36]), as well as all forms of ASA, SAS, SSS, more?*)

(*side-angle-side congruence/similarity sharing two sides: *)
(*side-angle-side congruence sharing no sides: *)

(*side-side-side congruence sharing one side: *)
(*side-side-side congruence sharing no sides: *)

(*angle-side-angle congruence sharing one side: *)
(*angle-side-angle congruence sharing no sides: *)

(*angle-angle similarity sharing no side: SEE ABOVE "similar1" THM .
for pure-angle similarity where the triangles share one side (congruence), hopefully our first congsim thm works,
or they are the same triangle and we dont need congsim thms at all*)
};


(*///////////////////////          AREAS         ///////////////////////////*)
areathms = {
(*
basic area addition/subtraction:
we begin by using 'signed area', since it's used in the area method, and might be harder to add later. (a twisted quadrilateral can have area 0?)
Actually we are just keeping a consistent sign (which is consistent with, and is helped by, our use of 'sign'-of-angles agnostisism), 
NO:
As with angles, I am assuming triangles and even polygons have a consistent orientation. 
(which all agree, even to the point that if there is an Angle[a,b,c], 
then there better NOT be Triangle[c,b,a] or Polygon[...,c,b,a,...] 
- or we will change one, or the Angle or the area of the polygon is negative)
*)
 {___,
a1:GeometricArea[{x___, y_, z_, w___}]==area1_ (* {x}[[1]] is assumed to complete the cycle*),
___,
a2:GeometricArea[{lmor___, z_, y_, rmor___}|{y_, rmor___, lmor___, z_}|{rmor___, y_, z_, lmor___}|{z_, lmor___, rmor___, y_}]==area2_,
___} /; FreeQ[{x,w,lmor,rmor},y|z] && DisjointQ[{x,w},{lmor,rmor}] && !(area1==area2 && MatchQ[a2[[1,1]],{rmor, y, z, lmor}|{z, lmor, rmor, y}])
:>((*Print[{y,z,y|z},{a1,a2},{w,x,y,z,lmor,rmor}];*)
	applyTheorem["area-add", 
		{a1,a2}, 
		
			If[MatchQ[a2[[1,1]],{rmor, y, z, lmor}|{z, lmor, rmor, y}], 
				If[area2>area1,
					GeometricArea[areaVertexSort[(*Reverse@{x,y,rmor,lmor,z,w}*){rmor,y,x,w,z,lmor}]] == area2-area1,
					GeometricArea[areaVertexSort[(*{x,y,rmor,lmor,z,w}*)Reverse@{rmor,y,x,w,z,lmor}]] == area1-area2
				], 
				GeometricArea[areaVertexSort[{x,y,rmor,lmor,z,w}]] == area1+area2
		](*signed addition if y-z is reversed in second area?? *),
		"DisplayProofData"->{
			If[MatchQ[a2[[1,1]],{rmor, y, z, lmor}],"add","subtract"],
			If[area2>area1 && MatchQ[a2[[1,1]],{rmor, y, z, lmor}|{z, lmor, rmor, y}], 
				areaVertexSort[Reverse@{rmor,y,x,w,z,lmor}],
				areaVertexSort[{x,y,rmor,lmor,z,w}]
			](*{{w},{x},{y},{z},{lmor},{rmor}}*), 
			a1, a2
		}
	]),
(*area subtraction - this includes reverse substraction*)	
{___,
a2:GeometricArea[{x___, y_, mor__, z_, w___}]==area2_ (* {x}[[1]] is assumed to complete the cycle*),
___,
a1:GeometricArea[pts_]==area1_,
___}|{___,
a1:GeometricArea[pts_]==area1_,
___,
a2:GeometricArea[{x___, y_, mor___, z_, w___}]==area2_,
___} /; MatchQ[areaVertexSort[pts],areaVertexSort[(*Reverse@*){x, y, z, w}]](*TrueQ[area2>area1] &&*) && !(mor===(*mor1===*){}) && FreeQ[{x,w,mor(*,mor1*)},y|z] && DisjointQ[{x,w},{mor(*,mor1*)}] (*&& DisjointQ[{mor},{mor1}]*)
:>((*Print[If[MatchQ[a2[[1,1]],{GeometricPoint["b"],GeometricPoint["y"],GeometricPoint["x"],GeometricPoint["a"]}],"YYROEOREOYREO",""],{area1,area2},{x, y, mor, z, w},areaVertexSort[pts],{{}},GeometricArea[areaVertexSort[{y,mor,z}]],"\n", {{{{}}}},{y,z,y|z},{a1,a2},{{w},{x},{y},{z},{mor}}];*)
	applyTheorem["area-subtract", 
		{a1,a2}, 
		If[TrueQ[area2>area1],GeometricArea[areaVertexSort[{y,mor,z}]]==area2-area1, GeometricArea[areaVertexSort[Reverse@{y,mor,z}]]==area1-area2](*signed addition if y-z is reversed in second area?? *),
		"DisplayProofData"->{{{w},{x},{y},{z},{mor}}, a1, a2}
	]),

(*
to area triangle from base,height. - but how do we know where to draw a perpendicular height that can be found?
*)
 {___,
Parallel[___,l1:InfiniteLineThrough[{___,y_,___,w_,___,z_,___}]|InfiniteLineThrough[{___,w_,___,y_,___,z_,___}]|InfiniteLineThrough[{___,y_,___,z_,___,w_,___}],___],
___,
a1:EuclideanDistance[x_, w_]==borh1_|EuclideanDistance[w_, x_]==borh1_,
___,
a2:EuclideanDistance[y_, z_]==borh2_|EuclideanDistance[z_, y_]==borh2_(*the BASE of the triangle. not needed if we enforce consistency with lines above?*),
___,
ang:(Angle[x_,w_,(y_)|(z_),t___]|Angle[(y_)|(z_),x_,w_,t___])==_?(#==90&),
___}|{___,
Parallel[___,l1:InfiniteLineThrough[{___,y_,___,w_,___,z_,___}]|InfiniteLineThrough[{___,w_,___,y_,___,z_,___}]|InfiniteLineThrough[{___,y_,___,z_,___,w_,___}],___],
___,
a2:EuclideanDistance[y_, z_]==borh2_|EuclideanDistance[z_, y_]==borh2_(*the BASE of the triangle. not needed if we enforce consistency with lines above?*),
___,
a1:EuclideanDistance[x_, w_]==borh1_|EuclideanDistance[w_, x_]==borh1_,
___,
ang:(Angle[x_,w_,(y_)|(z_),t___]|Angle[(y_)|(z_),x_,w_,t___])==_?(#==90&),
___} /; FreeQ[{a1,a2},HoldPattern[(Max|Min)[__]],Heads->True]
:>((*Print["FDFDS11",Column[{x,y,z,w}],{a1,a2,ang},{xXnor[MatchQ[ang,Angle[x,w,___]], MatchQ[l1,InfiniteLineThrough[___,y,___,w,___,z,___]]],Xnor[MatchQ[ang,Angle[x,w,___]|Angle[x,w,___]], MatchQ[l1,InfiniteLineThrough[___,y,___,w,___,z,___]]]}];*)
	applyTheorem["tri-to-area", {a2,a1,ang}, geomPrint["tri-to-area",{a2,a1}];
		GeometricArea[areaVertexSort[
			If[
				Xnor[
					MatchQ[ang[[1]],Angle[x,w,___]], 
					MatchQ[l1,InfiniteLineThrough[{___,y,___,w,___,z,___}]]
				], 
				(*Print[{z,x,y}//TraditionalForm];*) {z,x,y}, 
				(*Print[{x,z,y}//TraditionalForm];*){x,z,y}
			]		
		]]==(borh1 borh2/2)
	(**)]),

(*special right triangle version of above thm*)
 {___,
a1:EuclideanDistance[x_, z_]==borh1_|EuclideanDistance[z_, x_]==borh1_,
___,
a2:EuclideanDistance[y_, x_]==borh2_|EuclideanDistance[x_, y_]==borh2_(*not needed if we enforce consistency with lines above*),
___,
ang:(Angle[z_,x_,y_,t___]|Angle[y_,x_,z_,t___])==_?(#==90&),
___} /; FreeQ[{a1,a2},HoldPattern[(Max|Min)[__]],Heads->True]
:>((*Print["FDFDS",{a1,a2,ang},{z,x,y},MatchQ[ang,Angle[z,x,y,___]==_],If[MatchQ[ang,Angle[z,x,y,___]==_], {z,x,y}, {x,z,y}],GeometricArea[areaVertexSort[If[MatchQ[ang,Angle[z,x,y,___]], {z,x,y}, {x,z,y}]]]==4343434];*)
	applyTheorem["tri-to-area", {a1,a2,ang}, GeometricArea[areaVertexSort[If[MatchQ[ang,Angle[z,x,y,___]==_], {z,x,y}, {x,z,y}]]]==(borh1 borh2/2)(**)]),


(*
from area triangle and height
*)
{___,
Parallel[___,l1:InfiniteLineThrough[{___,y_,___,w_,___,z_,___}]|InfiniteLineThrough[{___,w_,___,y_,___,z_,___}]|InfiniteLineThrough[{___,y_,___,z_,___,w_,___}],___],
___,
a1:EuclideanDistance[x_, w_]==height_|EuclideanDistance[w_, x_]==height_,
___,
a2:GeometricArea[{p1_, p2_, p3_}]== area_ (* *),
___,
ang:(Angle[x_,w_,(y_)|(z_),t___]|Angle[(y_)|(z_),w_,x_,t___])==90,
___} /; Sort[{p1,p2,p3}]===Sort[{x,y,z}]
:>(applyTheorem["tri-from-area1", {a1,a2}, EuclideanDistance@@vSort[{y,z}]== 2 area/height (* *)])
};



(* FUTURE
from area triangle and base
REMINDER:
CHANGE TO NEW \[Equal] NOTATION!!!
*)
 (*{___,
a1:EuclideanDistance[x_, y_, base_ (* *)],
___,
a:GeometricArea[{x_, y_, z_}\[Rule]area_ (* *)],
___}
:>(applyTheorem["tri-from-area2", {a1,a2}, With[{newp=makeNewPoint[]},2 area / base; Parallel[]]]),*)

(*
(*
to area trapezoid: (a+b)h/2, special tf formatting for parallelograms, squares,...but here one rule 4 speed
*)
 {___,
a1:GeometricArea[{x__, w__}\[Rule]area1_ (* {x}[[1]] is assumed to complete the cycle*)],
___,
a2:GeometricArea[{x__, y_, z_, w__}\[Rule]area2_ (* {x}[[1]] is assumed to complete the cycle*)],
___}
:>(applyTheorem["areaadd", {a1,a2}, GeometricArea[{x[[-1]], y, z, w[[1]]}\[Rule]area1+area2(*signed addition*)]]),

(*
from area parallelogram
*)
 {___,
a1:GeometricArea[{x__, w__}\[Rule]area1_ (* {x}[[1]] is assumed to complete the cycle*)],
___,
a2:GeometricArea[{x__, y_, z_, w__}\[Rule]area2_ (* {x}[[1]] is assumed to complete the cycle*)],
___}
:>(applyTheorem["areaadd", {a1,a2}, GeometricArea[{x[[-1]], y, z, w[[1]]}\[Rule]area1+area2(*signed addition*)]]),
*)

(*areas of triangles from lengths/angles (but no trig?) *)

(*areas of quadrilaterals from lengths/angles*)



(*///////////////////////          CIRCLES         ///////////////////////////*)
(*  CircleThrough[{points, in, a, consistent, counterclockwise, order}, centerpoint, radius]*)
circthms = {
(* trivial radius to lengths rule - another case where we COULD have multiple conclusions, but don't need to here *)
{___,
Parallel[___,l:InfiniteLineThrough[{___,centerpt_,___,pt_,___}]|InfiniteLineThrough[{___,pt_,___,centerpt_,___}],___],
___,
c:CircleThrough[{___,pt_,___},centerpt_,rad_],
___}
:> applyTheorem["circrad", 
		{c}, 
		(*If[MatchQ[l,InfiniteLineThrough[{___,centerpt,___,pt,___}]],
			EuclideanDistance[centerpt, pt]==rad,
			EuclideanDistance[pt, centerpt]==rad
		]*)EuclideanDistance@@vSort[{centerpt, pt}]==rad
	],


(*two tangent circles - just get this from diagram in preprocessing, noting that there is only one point in common?
similarly with tangent line to circ: **any other circle would have another point in common or no points in common**
-MAYBE BETTER FOR THIS TO REARRANGE LINES, THEN LENGTH ADDITION WILL DO IT
TWO POSSIBILITIES: COULD BE ONE CIRC INSIDE OTHER! (so subtract radii)
*)
{___,
c1:CircleThrough[{a___,pt_,b___},centerpt1_,rad1_],
___,
c2:CircleThrough[{c___,pt_,d___},centerpt2_,rad2_],
___} /; Intersection[{a,b},{c,d}]==={}
:>(applyTheorem["circtang", {c1,c2}, EuclideanDistance[Sequence@@vSort[{centerpt1, centerpt2}]] == rad1+rad2]),


(* arc lengths to central angles *)

(* central angles to *arc lengths *)

(*angle subtended rules*)
(*from central angle*)


(*Angle["p","v","w",39/2]\[Rule]heldgetProof["circsubtend1",{CircleThrough[{"p","v","w"},"c",5],Angle["p","c","w",39]},Angle["p","v","w",39/2]]

if angles are always turning right (left) and <180 (if =180 we combine lines), and circles going counterclockwise (clockwise), 
then a central angle pcw and a circle involving pvw IMPLIES that v is in the smaller (larger) arc between p and w on the circle,
so it has angle 180-a/2, by the general quadrilateral incribed rule
*)

{___,
c1:CircleThrough[pts:{___,y_,___},centerpt_,rad_],
___,
ang:Angle[x_,centerpt_,z_,t___]==a_(*|Angle[z_,centerpt_,x_,a_,t___] -fine but not nec*),
___} /; y=!=x && y=!=z && MemberQ[pts,z] && MemberQ[pts,x]  (*-assumed?*)
:>(If[MatchQ[pts,{___,x,___,y,___,z,___}|{___,z,___,x,___,y,___}|{___,y,___,z,___,x,___}], 
		applyTheorem["circsubtend1a", {c1,ang}, Angle[z,y,x,t]==180-a/2],
		applyTheorem["circsubtend1b", {c1,ang}, Angle[x,y,z,t]==a/2]
	]),
	
(*angles that subtend a diameter are 90 deg*)


(*to central angle*)
{___,
c1:CircleThrough[pts:{___,y_,___},centerpt_,rad_],
___,
ang:Angle[x_,y_,z_,t___]==a_(*|Angle[z_,centerpt_,x_,a_,t___] -fine but not nec*),
___} /; y=!=x && y=!=z && MemberQ[pts,z] && MemberQ[pts,x]  (*-assumed?*)
:>(applyTheorem["circsubtend2", {c1,ang}, 
	If[a>90,  (*this is a cool 'cheat': if a>90, we know that it is on the smaller arc between z and x, thus also the angle xyz must *)
		Angle[z,centerpt,x,t]==2 (180-a), 
		Angle[x,centerpt,z,t]==2 a,
		{}
	]
]),

(*arc length to & from rules
preserve ccw/right-turn rules in CircleArcLength
faster to refer to the circle (a hash) of which the arc is a part? *)
{___,
c1:CircleThrough[pts:{___,y_,___},centerpt_,rad_],
___,
ang:((*Angle[x_,centerpt_,z_,t___]|*)Angle[z_,centerpt_,x_,t___])==a_,
___} /; y=!=x && y=!=z && MemberQ[pts,x] && MemberQ[pts,z]
:>(applyTheorem["to-circ-arc", {c1,ang},
	If[ang[[1]]===x, 
		CircleArcLength[centerpt,{x,z}, a] == a rad Pi/180, 
		CircleArcLength[centerpt,{z,x}, a] == a rad Pi/180
	]
]),

{___,
c1:CircleThrough[pts:{___,y_,___},centerpt_,rad_],
___,
ca:CircleArcLength[centerpt_,(*rad_, - not needed since we'll have GeometricCircle, and may not have! *){x_, z_}, a_, len_],
___}
:>(applyTheorem["from-circ-arc", {c1,ca}, 
	Angle[x,centerpt,z]==If[NumericQ[a], a, len/(rad Pi/180)]
]),

(* *OLD version of tangency*
THIS IS NOT YET WORKING BECAUSE (e.g. diags[5] giving distance(v, cen2)\[LongEqual]9), 
THERE IS NO WAY TO ADD EXTRA INTERSECTION POINTS IN PrepDiag[], AND CANT NEC. DO THIS IN IMAGE REC. STEP IF NO LINE IS DRAWN!?
*)
(*two tangent lines to a circ make equal segments from their intersection point to points of tang. *)
(*{___,
Parallel[___,l1:InfiniteLineThrough[{___,x_,___,tp1_,___}]|InfiniteLineThrough[{___,tp1_,___,x_,___}],___,,___],
___,
Parallel[___,l2:InfiniteLineThrough[{___,x_,___,tp2_,___}]|InfiniteLineThrough[{___,tp2_,___,x_,___}],___],
___,
c:GeometricCircle[centerpt_,rad_,pts:{___,tp1_,___,tp2_,___}|{___,tp2_,___,tp1_,___}],
___,
l:EuclideanDistance[tp1_,x_]==len_|EuclideanDistance[x_,tp1_]==len_|EuclideanDistance[x_,tp2_]==len_|EuclideanDistance[tp2_,x_]==len_,
___} /; Intersection[List@@l1,pts]==={tp1} && Intersection[List@@l2,pts]==={tp2}
:>*)

{___,
	Tangent[___,
		l1:InfiniteLineThrough[{___,x_,___,tp1_,___}]|InfiniteLineThrough[{___,tp1_,___,x_,___}],___,
		c:CircleThrough[pts:{___,tp1_,___,tp2_,___}|{___,tp2_,___,tp1_,___},centerpt_,rad_],
	___],
___,
	Tangent[___,
		l2:InfiniteLineThrough[{___,x_,___,tp2_,___}]|InfiniteLineThrough[{___,tp2_,___,x_,___}],___,
		c:CircleThrough[pts:{___,tp1_,___,tp2_,___}|{___,tp2_,___,tp1_,___},centerpt_,rad_],
	___],
___,
	l:EuclideanDistance[tp1_,x_]==len_|EuclideanDistance[x_,tp1_]==len_|EuclideanDistance[x_,tp2_]==len_|EuclideanDistance[tp2_,x_]==len_,
___} /; Intersection[List@@l1,pts]==={tp1} && Intersection[List@@l2,pts]==={tp2}
:> (applyTheorem["circ-tang-lengths", {l1,l2,c,l}, 
	If[MatchQ[l[[1]],EuclideanDistance[tp1,x]|EuclideanDistance[x,tp1]],
		If[MatchQ[l2, InfiniteLineThrough[{___,x,___,tp2,___}]],EuclideanDistance@@vSort[{x,tp2}]==len,EuclideanDistance@@vSort[{tp2,x}]==len],
		If[MatchQ[l1, InfiniteLineThrough[{___,x,___,tp1,___}]],EuclideanDistance@@vSort[{x,tp1}]==len,EuclideanDistance@@vSort[{tp1,x}]==len]
	]
])


};




(*should put length here too? or move this to the general Reducing func*)

anglecontradictionthm = (*{"angle-contradiction"->*){

(*inconsis. angles*)
{___,
a1:Angle[y_,x_,z_,t___]==a_?NumericQ,
___,
a2:Angle[y_,x_,z_,t___]==b_?NumericQ,
___} /; a!=b
:>((*Print["angle contradict!!"];*)(*heldgetProof*)applyTheorem["specialcase",{a1, a2},"Contradiction"]),

{___,
a1:HoldPattern[EuclideanDistance[y__]==a_?NumericQ],
___,
a2:HoldPattern[EuclideanDistance[y__]==b_?NumericQ],
___} /; a!=b
:>((*Print["angle contradict!!"];*)(*heldgetProof*)applyTheorem["specialcase",{a1, a2},"Contradiction"])

}(*}*);


thmlabs = {"length thms", "angle thms", "len-ang thms", "area thms", "cong/sim thms", "circ thms"};
thms = (*Join[anglethms(*lengththms,*) (*lenangthms, *)(*areathms,*) (*congsimthms*)(*, circthms*)]*)
Thread[thmlabs->{lengththms,anglethms, lenangthms, areathms, congsimthms, circthms}];


fixedthms = thms/.{ang:HoldPattern[Angle[a_,b_,c_,t___]==r_]:>Angle[a,b,c]==r};


(* ::Section:: *)
(*Generating images from a diagram*)


(* ::Section::Closed:: *)
(*EndPackage*)


EndPackage[]

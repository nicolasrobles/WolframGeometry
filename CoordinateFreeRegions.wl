(* ::Package:: *)

(* ::Text:: *)
(*New symbols are marked with asterisks. *)


(* ::Title:: *)
(*Top level functions*)


(* ::Section::Closed:: *)
(*GeometricScene**)


(* ::Text:: *)
(*GeometricScene[{hyp1, hyp2, \[Ellipsis]}, {p1, p2, \[Ellipsis]}] represents a 2D geometric scene description consisting of the hypotheses hypi and the points pi.*)


(* ::Text:: *)
(*GeometricScene[hyps, ps, {conj11, conj2, \[Ellipsis]}] represents a scene together with some conjectures conji about the scene.*)


(* ::Subsection:: *)
(*Details*)


(* ::Text:: *)
(*The hypi may be regions such as Triangle, Polygon, Circle, etc. as well as hypotheses about those regions using Element, Parallel, Concurrent, etc.*)


(* ::Text:: *)
(*Explicit coordinates may be given for the pi by using pi -> {xi, yi}. If coordinates are given for each of the points, GeometricScene formats as Graphics. Additionally, if conjectures are given, GeometricScene formats as a TabView, allowing users to highlight parts of the scene corresponding to each of the conji.*)


(* ::Text:: *)
(*The hypi may use Style.*)


(* ::Subsection:: *)
(*Discussion*)


(* ::Text:: *)
(*Currently, we are just using a list of hypotheses to represent a scene description and are wrapping all of the points with GeometricPoint. I think this new proposal is much nicer for several reasons, not least of which because a satisfactory name for GeometricPoint eludes us.*)


(* ::Text:: *)
(*Auto-normalization? We could allow users to omit the list of points and use heuristics to determine them, similar to Solve. Conjectures that appear verbatim in the hypotheses could be omitted from the conjectures, the conjectures could be automatically sorted according to the PriorityFunction option.*)


(* ::Text:: *)
(*Options? "Labeling"->{"Points"|"Angles"|"Lengths"|...}? SceneLayout, EmphasizeFacts->n|{n}, PriorityFunction -> Automatic?*)


(* ::Text:: *)
(*Should we keep user provided conjectures and conjectures generated by FindGeometricConjectures; e.g. GeometricScene[hyps, ps, {userconjs, systemconjs}]?*)


(* ::Section::Closed:: *)
(*FindGeometricSceneRealization**)


(* ::Text:: *)
(*FindGeometricSceneRealization[scene] searches for coordinates for the points appearing in scene that satisfy the scene description.*)


(* ::Subsection:: *)
(*Details*)


(* ::Text:: *)
(*FindGeometricSceneRealization returns a GeometricScene with coordinates given for each of the points.*)


(* ::Subsection:: *)
(*Discussion*)


(* ::Text:: *)
(*This would subsume our current FindGeometricSceneGraphics and FindGeometricSceneCoordinates. FindGeometricSceneGraphics returns Graphics annotated with the original scene description and the coordinates.*)


(* ::Text:: *)
(*This should take options like WorkingPrecision, PrecisionGoal, AccuracyGoal, PerformanceGoal, TimeConstraint, RandomSeeding, etc. Any others?*)


(* ::Section::Closed:: *)
(*FindGeometricConjectures**)


(* ::Text:: *)
(*FindGeometricConjectures[scene] searches for conjectures that might hold for scene.*)


(* ::Subsection:: *)
(*Details*)


(* ::Text:: *)
(*FindGeometricConjectures returns a GeometricScene with a list of conjectures, sorted according to a PriorityFunction.*)


(* ::Subsection:: *)
(*Discussion*)


(* ::Text:: *)
(*This should take most if not all of the same options as FindGeometricSceneRealiziation. PriorityFunction option?*)


(* ::Section::Closed:: *)
(*FindGeometricProof**)


(* ::Text:: *)
(*FindGeometricProof[scene] attempts to prove the conjectures given in scene.*)


(* ::Subsection:: *)
(*Details and options*)


(* ::Text:: *)
(*With the option Method -> "Synthetic", FindGeometricProof attempts to find a synthetic two-column proof of conjecture. Other options include "AreaMethod", "GroebnerBasis", etc.*)


(* ::Text:: *)
(*FindGeometricProof returns a ProofObject.*)


(* ::Title:: *)
(*Scene description language*)


(* ::Chapter:: *)
(*Representing points*)


(* ::Section::Closed:: *)
(*Midpoint**)


(* ::Text:: *)
(*Midpoint[Line[{P,Q}]] gives the midpoint of the line segment connecting the points P and Q.*)


(* ::Subsection:: *)
(*Details*)


(* ::Text:: *)
(*Midpoint[Line[{p,q}]] is equivalent to RegionCenter[Line[{p,q}],"Midpoint"].*)


(* ::Subsection:: *)
(*Discussion*)


(* ::Text:: *)
(*This could also be used on proper circle arcs. Note that it would not coincide with the RegionCentroid.*)


(* ::Text:: *)
(*This could in principle be used with ParametricRegion (the point at which the arc length before the point equals the arc length after), but it wouldn't correspond to a geometric midpoint if the parametrization is not injective.*)


(* ::Text:: *)
(*This could in principle be used with arbitrary 1D regions, but they would need to be connected, rectifiable curves with distinct endpoints and no self-intersections.*)


(* ::Section::Closed:: *)
(*RegionCenter**)


(* ::Text:: *)
(*RegionCenter[reg,"center"] gives the special center of the region reg specified by "center".*)


(* ::Subsection:: *)
(*Details*)


(* ::Text:: *)
(*Possible values for "center" include "Midpoint", "Centroid", "Orthocenter", "Incenter","Circumcenter", etc.*)


(* ::Text:: *)
(*RegionCenter[reg,"Centroid"] is equivalent to RegionCentroid[reg].*)


(* ::Text:: *)
(*RegionCenter[reg,"Midpoint"] is equivalent to Midpoint[reg].*)


(* ::Subsection:: *)
(*Possible issues*)


(* ::Text:: *)
(*Some centers may only be applicable to certain regions/dimensions.*)


(* ::Section::Closed:: *)
(*RegionCentroid*)


?RegionCentroid


(* ::Section::Closed:: *)
(*RegionNearest*)


?RegionNearest


(* ::Chapter:: *)
(*Representing regions*)


(* ::Section::Closed:: *)
(*AffineHull**)


(* ::Text:: *)
(*AffineHull[reg] gives the smallest affine subspace containing the region reg.*)


(* ::Subsection:: *)
(*Discussion*)


(* ::Text:: *)
(*Won't appear inside GeometricScene, but would be needed to implement Parallel and Perpendicular for arbitrary regions.*)


(* ::Section::Closed:: *)
(*AngleBisector**)


(* ::Text:: *)
(*AngleBisector[P,Q,R] gives the angle bisector of the angle \[Angle]PQR.*)


(* ::Subsection:: *)
(*Details*)


(* ::Text:: *)
(*AngleBisector returns an InfiniteLine when explicit coordinates are given.*)


(* ::Subsection:: *)
(*Discussion*)


(* ::Text:: *)
(*This assumes 2D. Should an angle bisector be a hyperplane in higher dimensions? It could also still be an infinite line as long as the points are not collinear. *)


(* ::Section::Closed:: *)
(*CircleThrough**)


(* ::Text:: *)
(*CircleThrough[{P1,P2,\[Ellipsis]}] represents a circle passing through the points P1, P2, \[Ellipsis].*)
(*CircleThrough[{P1,P2,\[Ellipsis]}, Q ] represents a circle passing through the points P1, P2, \[Ellipsis] and with center Q.*)
(*CircleThrough[{P1,P2,\[Ellipsis]}, Q, r] represents a circle passing through the points P1, P2, \[Ellipsis], with center Q, and radius r.*)


(* ::Subsection:: *)
(*Details*)


(* ::Text:: *)
(*CircleThrough returns a Circle when explicit coordinates are given. If a unique circle passing through the points does not exist, CircleThrough remains unevaluated.*)


(* ::Subsection:: *)
(*Possible issues*)


(* ::Text:: *)
(*Unlike Circumsphere, CircleThrough may under- or overdetermine the circle.*)


(* ::Subsection:: *)
(*Discussion*)


(* ::Text:: *)
(*Our current scene descriptions assume that the points are ordered counterclockwise. Do we want this in all cases?*)
(**)
(*Yes, for the synthetic prover I would (well, not necessarily ccw, but whatever the angles are interpreted as - all cw or all ccw)*)


(* ::Section::Closed:: *)
(*InfiniteLineThrough**)


(* ::Text:: *)
(*InfiniteLineThrough[{p1,p2,\[Ellipsis]}] represents an infinite line passing through the sequence of points pi.*)


(* ::Subsection:: *)
(*Details*)


(* ::Text:: *)
(*InfiniteLineThrough returns an InfiniteLine when explicit coordinates are given. If the points are not colinear, InfiniteLineThrough remains unevaluated.*)


(* ::Subsection:: *)
(*Discussion*)


(* ::Text:: *)
(*See LineThrough. Unsure if this should be an ordered construct.*)


(* ::Text:: *)
(*Synthetic prover currently assumes ordered points*)


(* ::Section::Closed:: *)
(*LineThrough**)


(* ::Text:: *)
(*LineThrough[{p1,p2,\[Ellipsis]}] represents a line segment passing through the sequence of points pi.*)


(* ::Subsection:: *)
(*Details*)


(* ::Text:: *)
(*LineThrough returns a Line when explicit coordinates are given. If the points are not colinear, LineThrough remains unevaluated.*)


(* ::Subsection:: *)
(*Discussion*)


(* ::Text:: *)
(*The idea for now is that this is an ordered construct. What do we think? Do we need UnorderedLineThrough?*)


(* ::Text:: *)
(*Synthetic prover currently assumes ordered points, although it doesn't have a lot of use so far for this (saying C is between A and B). We could just put C into an InfiniteLineThrough of the appropriate *)


(* ::Section::Closed:: *)
(*PerpendicularBisector**)


(* ::Text:: *)
(*PerpendicularBisector[P,Q] gives the perpendicular bisector of the line segment connecting P and Q.*)


(* ::Text:: *)
(*PerpendicularBisector[Line[{P,Q}]] gives the perpendicular bisector of the line segment connecting P and Q.*)


(* ::Subsection:: *)
(*Details*)


(* ::Text:: *)
(*PerpendicularBisector returns an InfiniteLine when explicit coordinates are given.*)


(* ::Subsection:: *)
(*Discussion*)


(* ::Text:: *)
(*This assumes 2D. Should the perpendicular bisector of a line segment be a hyperplane in higher dimensions?*)


(* ::Section::Closed:: *)
(*Circle/Disk*)


?Circle


(* ::Subsection:: *)
(*Discussion*)


(* ::Text:: *)
(*See Unspecified and CircleThrough.*)


(* ::Section::Closed:: *)
(*Circumsphere*)


?Circumsphere


(* ::Subsection:: *)
(*Details*)


(* ::Text:: *)
(*Should this apply to arbitrary regions?*)


(* ::Text:: *)
(*Is it an issue that this gives a Sphere in 2D rather than a Circle?*)


(* ::Section::Closed:: *)
(*InfiniteLine*)


?InfiniteLine


(* ::Section::Closed:: *)
(*Insphere*)


?Insphere


(* ::Subsection:: *)
(*Details*)


(* ::Text:: *)
(*Should this apply to arbitrary regions?*)


(* ::Text:: *)
(*Is it an issue that this gives a Sphere in 2D rather than a Circle?*)


(* ::Section::Closed:: *)
(*Line*)


?Line


(* ::Section::Closed:: *)
(*Point*)


?Point


(* ::Section::Closed:: *)
(*Polygon*)


?Polygon


(* ::Section::Closed:: *)
(*RegionBoundary*)


?RegionBoundary


(* ::Section:: *)
(*RegionDifference/RegionSymmetricDifference*)


(* ::Section::Closed:: *)
(*RegionIntersection/RegionUnion*)


?RegionIntersection


?RegionUnion


(* ::Section::Closed:: *)
(*Triangle*)


?Triangle


(* ::Chapter:: *)
(*Representing hypotheses*)


(* ::Section::Closed:: *)
(*Collinear/Coplanar**)


(* ::Text:: *)
(*Coplanar[X1,X2,\[Ellipsis]] states that the geometric objects X1, X2, \[Ellipsis] are coplanar.*)


(* ::Subsection:: *)
(*Details*)


(* ::Text:: *)
(*A collection of geometric objects are coplanar if the affine hull of their union is two-dimensional.*)


(* ::Text:: *)
(*The option "Dimension" can be used to specify the dimension of the affine subspace.*)


(* ::Text:: *)
(*Coplanar[\[Ellipsis],"Dimension"->1] is equivalent to Collinear[\[Ellipsis]].*)


(* ::Section::Closed:: *)
(*Concurrent**)


(* ::Text:: *)
(*Concurrent[L1,L2,\[Ellipsis]] states that the lines L1, L2 are concurrent.*)


(* ::Subsection:: *)
(*Details*)


(* ::Text:: *)
(*A collection of lines is concurrent if they all intersect at a single point.*)


(* ::Subsection:: *)
(*Discussion*)


(* ::Text:: *)
(*Should we generalize this? This is essentially a degeneracy condition, but there are other kinds of degeneracy conditions for other regions/dimensions:*)


(* ::Item:: *)
(*Three lines being coplanar in higher dimensions.*)


(* ::Item:: *)
(*Three planes intersecting in a line*)


(* ::Item:: *)
(*Three planes intersecting in a point*)


(* ::Section::Closed:: *)
(*Convex**)


(* ::Text:: *)
(*Convex[reg] states that the region reg is convex.*)


(* ::Subsection:: *)
(*Details*)


(* ::Text:: *)
(*A region is convex if it contains all the line segments connecting any pair of its points.*)


(* ::Section::Closed:: *)
(*Cyclic**)


(* ::Text:: *)
(*Cyclic[Polygon[{X1,X2, \[Ellipsis]}]] states that the points X1, X2, \[Ellipsis] all lie on a circle.*)


(* ::Section::Closed:: *)
(*EqualAngles**)


(* ::Text:: *)
(*EqualAngles[{P1,P2,\[Ellipsis]},Q] states that the angles \[Angle]P1 Q P2, \[Angle]P2 Q P3, \[Ellipsis] are equal.*)


(* ::Subsection:: *)
(*Discussion*)


(* ::Text:: *)
(*What do we think?*)


(* ::Text:: *)
(*This one seems strange. Especially since we can use == for any two angles*)


(* ::Section::Closed:: *)
(*Equiangular**)


(* ::Text:: *)
(*Equiangular[X] states that the polygon X is equiangular.*)


(* ::Subsection:: *)
(*Details*)


(* ::Text:: *)
(*A polygon is equiangular if all of its angles are equal.*)


(* ::Section::Closed:: *)
(*Equilateral**)


(* ::Text:: *)
(*Equilateral[X] states that the polygon X is equilateral.*)


(* ::Subsection:: *)
(*Details*)


(* ::Text:: *)
(*A polygon is equilateral if all of its side lengths are equal.*)


(* ::Subsection:: *)
(*Discussion*)


(* ::Text:: *)
(*Should this apply to Line?*)


(* ::Section::Closed:: *)
(*Parallel**)


(* ::Text:: *)
(*Parallel[u,v] returns whether the vectors u and v are parallel.*)
(*Parallel[X1,X2,\[Ellipsis]] asserts that the geometric objects X1, X2, \[Ellipsis] are pairwise-parallel.*)


(* ::Subsection:: *)
(*Details*)


(* ::Text:: *)
(*Two vectors are considered parallel if one is a scalar multiple of the other.*)


(* ::Text:: *)
(*Two affine subspaces (e.g. lines, planes, etc.) are parallel if one can be translated to be contained in the other. *)


(* ::Text:: *)
(*Two geometric objects are parallel if their affine hulls are parallel.*)


(* ::Text:: *)
(*For the purposes of Parallel, a vector v is equivalent to InfiniteLine[0 v,v].*)


(* ::Subsection:: *)
(*Discussion*)


(* ::Text:: *)
(*Note that allowing self-parallelism contradicts MathWorld.*)


(* ::Text:: *)
(*Should the zero vector be parallel to everything?*)


(* ::Text:: *)
(*Do we like this business with affine hulls?*)


(* ::Section::Closed:: *)
(*Regular**)


(* ::Text:: *)
(*Regular[X] states that the polygon X is regular.*)


(* ::Subsection:: *)
(*Details*)


(* ::Text:: *)
(*A polygon is regular if it is equilateral and equiangular.*)


(* ::Subsection:: *)
(*Discussion*)


(* ::Text:: *)
(*What do we mean by polygon here? Only Polygon primitives? What about polylines, e.g. Line primitives? Do we allow self-intersections (e.g. regular pentagram)?*)


(* ::Section::Closed:: *)
(*Similar**)


(* ::Text:: *)
(*Similar[X1,X2,\[Ellipsis]] asserts that the geometric objects X1, X2, \[Ellipsis] are pairwise-similar.*)


(* ::Subsection:: *)
(*Details and options*)


(* ::Text:: *)
(*Two geometric figures are similar if there exists a similarity which maps one onto the other.*)


(* ::Text:: *)
(*Any two line segments are similar. The same is true for pairs of points, lines, and circles.*)


(* ::Text:: *)
(*With the option "Strict"->True, corresponding vertices must be mapped to each other. True is the default for polygon-like regions such as Line, Triangle, Polygon, etc. With the option "Strict"->False, only the existence of a similarity is needed.*)


(* ::Text:: *)
(*With the option "Direct"->True, there must exist a direct similarity; that is, one which does not require a reflection. With the option "Direct"->False (default), this is not required.*)


(* ::Section::Closed:: *)
(*Tangent**)


(* ::Text:: *)
(*Tangent[X1,X2,\[Ellipsis]] states that the geometric objects X1, X2, \[Ellipsis] are pairwise tangent.*)


(* ::Text:: *)
(*Tangent[{X1,X2},P] states that the geometric objects X1 and X2 are tangent at the point P.*)


(* ::Subsection:: *)
(*Details*)


(* ::Text:: *)
(*Two geometric objects are tangent if they have parallel tangent spaces at their points of intersection.*)


(* ::Text:: *)
(*Two geometric objects are tangent at a point if they intersect at that point have parallel tangent spaces at that point. *)


(* ::Subsection:: *)
(*Discussion*)


(* ::Text:: *)
(*Should a region be tangent to itself?*)


(* ::Text:: *)
(*This definition requires that the regions be sufficiently smooth to have a tangent at their point of intersection. Is this what we want?*)


(* ::Text:: *)
(*Should we additionally require that there is only one point of intersection in a neighborhood of the point of intersection?*)


(* ::Section::Closed:: *)
(*Congruent*)


?Congruent


(* ::Text:: *)
(*Congruent[X1,X2,\[Ellipsis]] asserts that the geometric objects X1, X2, \[Ellipsis] are congruent.*)


(* ::Subsection:: *)
(*Details*)


(* ::Text:: *)
(*Two geometric figures are congruent if there exists a congruence which maps one onto the other.*)


(* ::Text:: *)
(*Two polygons are congruent if their corresponding side lengths and angles are equal.*)


(* ::Text:: *)
(*Two line segments are congruent if they have the same length.*)


(* ::Text:: *)
(*Any two lines are congruent. Any two points are congruent.*)


(* ::Text:: *)
(*Two circles are congruent if they have the same radius.*)


(* ::Text:: *)
(*With the option "Strict"->True, corresponding vertices must be mapped to each other. True is the default for polygon-like regions such as Line, Triangle, Polygon, etc. With the option "Strict"->False, only the existence of a congruence is needed.*)


(* ::Text:: *)
(*With the option "Direct"->True, there must exist a direct congruence; that is, one which does not require a reflection. With the option "Direct"->False (default), this is not required.*)


(* ::Section::Closed:: *)
(*Perpendicular*)


?Perpendicular


(* ::Text:: *)
(*Perpendicular[u,v] returns whether the vectors u and v are perpendicular.*)


(* ::Text:: *)
(*Perpendicular[X1,X2,\[Ellipsis]] states that the geometric objects X1, X2, \[Ellipsis] are pairwise-perpendicular.*)


(* ::Subsection:: *)
(*Details*)


(* ::Text:: *)
(*Two vectors are considered perpendicular if their dot product is 0.*)


(* ::Text:: *)
(*Two affine subspaces X and Y (e.g. lines, planes, etc.) are perpendicular if for all vectors u and v parallel to X and Y respectively, u is perpendicular to v. *)


(* ::Text:: *)
(*Two geometric objects are perpendicular if their affine hulls are perpendicular.*)


(* ::Text:: *)
(*For the purposes of Perpendicular, a vector v is equivalent to InfiniteLine[0v,v].*)


(* ::Subsection:: *)
(*Discussion*)


(* ::Text:: *)
(*Do we like this business with affine hulls?*)


(* ::Section::Closed:: *)
(*RegionDisjoint*)


?RegionDisjoint


(* ::Section::Closed:: *)
(*RegionEqual*)


?RegionEqual


(* ::Section::Closed:: *)
(*RegionMember/Element*)


?RegionMember


(* ::Section::Closed:: *)
(*RegionWithin*)


?RegionWithin


(* ::Chapter:: *)
(*Representing measurements*)


(* ::Section::Closed:: *)
(*Angle**)


(* ::Text:: *)
(*Angle[P,Q,R] gives the angle \[Angle]PQR.*)


(* ::Subsection:: *)
(*Discussion*)


UnorientedAngle[a_,b_,c_] := VectorAngle[a-b,c-b]


(* ::Text:: *)
(*This has the benefits of always returning an angle in the range 0 <= \[Theta] <= \[Pi] and working in every dimension. A drawback is that it makes it hard (impossible?) to formulate the statement that the sum of the interior angles of an n-gon is \[Pi] (n - 2).*)


CounterclockwiseAngle[A_,B_,C_] := Module[
  {u = Normalize[A-B], v = Normalize[C-B], \[Theta]},
  Reduce[RotationTransform[\[Theta]][u] == v && 0 <= \[Theta] < 2\[Pi], \[Theta]][[2]]
];


ClockwiseAngle[A_,B_,C_] := CounterclockwiseAngle[C,B,A]


(* ::Text:: *)
(*Unclear how to generalize these either to the 1D or higher dimensional cases.*)


(* ::Text:: *)
(*These ideas don't fit into the current synthetic prover design, where the angles are usefully ambiguous, but consistent, between ccw and cw. *)
(*Even though the prover prefers to return angles in the range 0 <= \[Theta] <= \[Pi], though the priority has been maintaining cw/ccw coherence. *)
(*In theory both should be achievable, since switching the order would change ccw to cw and v.v. (there are four names for every angle). I will at some point go through the angle theorems again and see if this is achieved or can be.*)


(* ::Section::Closed:: *)
(*Inradius**)


(* ::Text:: *)
(*Inradius[reg] gives the radius of the largest Sphere contained in the region reg.*)


(* ::Subsection:: *)
(*Discussion*)


(* ::Text:: *)
(*Should this be subsumed by Radius (e.g. a second argument)?*)


(* ::Section::Closed:: *)
(*Radius**)


(* ::Text:: *)
(*Radius[reg] gives the radius of the circumscribing Sphere of the region reg.*)


(* ::Text:: *)
(*Radius[reg,"type"] gives the radius of the region reg of the type "type".*)


(* ::Subsection:: *)
(*Details*)


(* ::Text:: *)
(*Radius[reg] is sometimes called the circumradius of the region reg.*)


(* ::Text:: *)
(*Possible values for "type" include "Circumradius" and "Inradius".*)


(* ::Subsection:: *)
(*Discussion*)


(* ::Text:: *)
(*Are there more types of radii we may want? If not, we may just want to stick with Radius and Inradius.*)


(* ::Section::Closed:: *)
(*ArcLength*)


?ArcLength


(* ::Subsection:: *)
(*Discussion*)


(* ::Text:: *)
(*Can't support the second and third argument forms for synthetic geometry.*)
(**)
(*I have been including a construct just for circle arcs from a point to a point, but the closest existing usage comes is (that I see) is to specify from an (absolute) angle to an angle:*)


ArcLength[Circle[{0,0},1,{0,4Pi/3}]]


(* ::Text:: *)
(*Seems like Circle[] *could* support a point-to-point spec? even something like this, which already returns unevaluated:*)


Circle[{0,0},1,"ArcPoints"->{x,y}]


(* ::Section::Closed:: *)
(*Area*)


?Area


(* ::Subsection:: *)
(*Discussion*)


(* ::Text:: *)
(*Can't support the second and third argument forms for synthetic geometry.*)


(* ::Section::Closed:: *)
(*EuclideanDistance*)


?EuclideanDistance


(* ::Text:: *)
(*At the moment using a TraditionalFrm:*)


(Unprotect[EuclideanDistance];
EuclideanDistance /: MakeBoxes[EuclideanDistance[x_GeometricPoint,y_GeometricPoint,d_], TraditionalForm] := StringJoin["distance(",ToString[x[[1]]],", ",ToString[y[[1]]],") = ",ToString[d, FormatType->TraditionalForm]];
EuclideanDistance /: MakeBoxes[EuclideanDistance[x_GeometricPoint,y_GeometricPoint], TraditionalForm] := StringJoin["distance(",ToString[x[[1]]],", ",ToString[y[[1]]],")"];
Protect[EuclideanDistance];)


(* ::Section::Closed:: *)
(*Perimeter*)


?Perimeter


(* ::Subsection:: *)
(*Discussion*)


(* ::Text:: *)
(*Can't support the second and third argument forms for synthetic geometry.*)


(* ::Section::Closed:: *)
(*RegionDistance*)


?RegionDistance
